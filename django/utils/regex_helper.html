<!DOCTYPE html>
<html><head><title>joekychen/django » django › utils › regex_helper.py

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>regex_helper.py</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions for reversing a regular expression (used in reverse URL resolving).</span>
<span class="sd">Used internally by Django and not intended for external use.</span>

<span class="sd">This is not, and is not intended to be, a complete reg-exp decompiler. It</span>
<span class="sd">should be good enough for a large class of URLS, however.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Mapping of an escape character to a representative of that class. So, e.g.,
"\w" is replaced by "x" in a reverse URL. A value of None means to ignore
this sequence. Any missing key is mapped to itself.</p></td><td class="code"><div class="highlight"><pre><span class="n">ESCAPE_MAPPINGS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&quot;A&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="s">&quot;b&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="s">&quot;B&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="s">&quot;d&quot;</span><span class="p">:</span> <span class="s">&quot;0&quot;</span><span class="p">,</span>
    <span class="s">&quot;D&quot;</span><span class="p">:</span> <span class="s">&quot;x&quot;</span><span class="p">,</span>
    <span class="s">&quot;s&quot;</span><span class="p">:</span> <span class="s">&quot; &quot;</span><span class="p">,</span>
    <span class="s">&quot;S&quot;</span><span class="p">:</span> <span class="s">&quot;x&quot;</span><span class="p">,</span>
    <span class="s">&quot;w&quot;</span><span class="p">:</span> <span class="s">&quot;x&quot;</span><span class="p">,</span>
    <span class="s">&quot;W&quot;</span><span class="p">:</span> <span class="s">&quot;!&quot;</span><span class="p">,</span>
    <span class="s">&quot;Z&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Choice</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to represent multiple possibilities at this point in a pattern string.</span>
<span class="sd">    We use a distinguished type, rather than a list, so that the usage in the</span>
<span class="sd">    code is clear.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to represent a capturing group in the pattern string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">NonCapture</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to represent a non-capturing group in the pattern string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a reg-exp pattern, normalizes it to a list of forms that suffice for</span>
<span class="sd">    reverse matching. This does the following:</span>

<span class="sd">    (1) For any repeating sections, keeps the minimum number of occurrences</span>
<span class="sd">        permitted (this means zero for optional groups).</span>
<span class="sd">    (2) If an optional group includes parameters, include one occurrence of</span>
<span class="sd">        that group (along with the zero occurrence case from step (1)).</span>
<span class="sd">    (3) Select the first (essentially an arbitrary) element from any character</span>
<span class="sd">        class. Select an arbitrary character for any unordered class (e.g. &#39;.&#39;</span>
<span class="sd">        or &#39;\w&#39;) in the pattern.</span>
<span class="sd">    (5) Ignore comments and any of the reg-exp flags that won&#39;t change</span>
<span class="sd">        what we construct (&quot;iLmsu&quot;). &quot;(?x)&quot; is an error, however.</span>
<span class="sd">    (6) Raise an error on all other non-capturing (?...) forms (e.g.</span>
<span class="sd">        look-ahead and look-behind matches) and any disjunctive (&#39;|&#39;)</span>
<span class="sd">        constructs.</span>

<span class="sd">    Django&#39;s URLs for forward resolving are either all positional arguments or</span>
<span class="sd">    all keyword arguments. That is assumed here, as well. Although reverse</span>
<span class="sd">    resolving can be done using positional args when keyword args are</span>
<span class="sd">    specified, the two cannot be mixed in the same reverse() call.</span>
<span class="sd">    &quot;&quot;&quot;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Do a linear scan to work out the special features of this pattern. The
idea is that we scan once here and collect all the information we need to
make future decisions.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">non_capturing_groups</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">consume_next</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">pattern_iter</span> <span class="o">=</span> <span class="n">next_char</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span>
    <span class="n">num_args</span> <span class="o">=</span> <span class="mi">0</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>A "while" loop is used here because later on we need to be able to peek
at the next character and possibly go around without consuming another
one at the top of the loop.</p></td><td class="code"><div class="highlight"><pre>    <span class="k">try</span><span class="p">:</span>
        <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">([</span><span class="s">&#39;&#39;</span><span class="p">],</span>  <span class="p">[[]])</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;.&#39;</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Replace "any character" with an arbitrary representative.</p></td><td class="code"><div class="highlight"><pre>                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;|&#39;</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>FIXME: One day we'll should do this, but not in 1.0.</p></td><td class="code"><div class="highlight"><pre>                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&quot;^&quot;</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;$&#39;</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;)&#39;</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>This can only be the end of a non-capturing group, since all
other unescaped parentheses are handled by the grouping
section later (and the full group is handled there).</p>

<p>We regroup everything inside the capturing group so that it
can be quantified, if necessary.</p></td><td class="code"><div class="highlight"><pre>                <span class="n">start</span> <span class="o">=</span> <span class="n">non_capturing_groups</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">inner</span> <span class="o">=</span> <span class="n">NonCapture</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">start</span><span class="p">:])</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[:</span><span class="n">start</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">inner</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;[&#39;</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Replace ranges with the first character in the range.</p></td><td class="code"><div class="highlight"><pre>                <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">escaped</span> <span class="ow">or</span> <span class="n">ch</span> <span class="o">!=</span> <span class="s">&#39;]&#39;</span><span class="p">:</span>
                    <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;(&#39;</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>Some kind of group.</p></td><td class="code"><div class="highlight"><pre>                <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ch</span> <span class="o">!=</span> <span class="s">&#39;?&#39;</span> <span class="ow">or</span> <span class="n">escaped</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>A positional group</p></td><td class="code"><div class="highlight"><pre>                    <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;_</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">num_args</span>
                    <span class="n">num_args</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Group</span><span class="p">(((</span><span class="s">&quot;</span><span class="si">%%</span><span class="s">(</span><span class="si">%s</span><span class="s">)s&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">),</span> <span class="n">name</span><span class="p">)))</span>
                    <span class="n">walk_to_end</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">pattern_iter</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="s">&quot;iLmsu#&quot;</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>All of these are ignorable. Walk to the end of the
group.</p></td><td class="code"><div class="highlight"><pre>                        <span class="n">walk_to_end</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">pattern_iter</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;:&#39;</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>Non-capturing group</p></td><td class="code"><div class="highlight"><pre>                        <span class="n">non_capturing_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">ch</span> <span class="o">!=</span> <span class="s">&#39;P&#39;</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>Anything else, other than a named group, is something
we cannot reverse.</p></td><td class="code"><div class="highlight"><pre>                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Non-reversible reg-exp portion: &#39;(?</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">ch</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Non-reversible reg-exp portion: &#39;(?P</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">ch</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>We are in a named capturing group. Extra the name and
then skip to the end.</p></td><td class="code"><div class="highlight"><pre>                        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;&lt;&#39;</span><span class="p">:</span>
                            <span class="n">terminal_char</span> <span class="o">=</span> <span class="s">&#39;&gt;&#39;</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>We are in a named backreference.</p></td><td class="code"><div class="highlight"><pre>                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">terminal_char</span> <span class="o">=</span> <span class="s">&#39;)&#39;</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
                        <span class="k">while</span> <span class="n">ch</span> <span class="o">!=</span> <span class="n">terminal_char</span><span class="p">:</span>
                            <span class="n">name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                            <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
                        <span class="n">param</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>Named backreferences have already consumed the
parenthesis.</p></td><td class="code"><div class="highlight"><pre>                        <span class="k">if</span> <span class="n">terminal_char</span> <span class="o">!=</span> <span class="s">&#39;)&#39;</span><span class="p">:</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Group</span><span class="p">(((</span><span class="s">&quot;</span><span class="si">%%</span><span class="s">(</span><span class="si">%s</span><span class="s">)s&quot;</span> <span class="o">%</span> <span class="n">param</span><span class="p">),</span> <span class="n">param</span><span class="p">)))</span>
                            <span class="n">walk_to_end</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">pattern_iter</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Group</span><span class="p">(((</span><span class="s">&quot;</span><span class="si">%%</span><span class="s">(</span><span class="si">%s</span><span class="s">)s&quot;</span> <span class="o">%</span> <span class="n">param</span><span class="p">),</span> <span class="bp">None</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">ch</span> <span class="ow">in</span> <span class="s">&quot;*?+{&quot;</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>Quanitifers affect the previous item in the result list.</p></td><td class="code"><div class="highlight"><pre>                <span class="n">count</span><span class="p">,</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">get_quantifier</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">pattern_iter</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ch</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>We had to look ahead, but it wasn't need to compute the
quanitifer, so use this character next time around the
main loop.</p></td><td class="code"><div class="highlight"><pre>                    <span class="n">consume_next</span> <span class="o">=</span> <span class="bp">False</span>

                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">contains</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Group</span><span class="p">):</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>If we are quantifying a capturing group (or
something containing such a group) and the minimum is
zero, we must also handle the case of one occurrence
being present. All the quantifiers (except {0,0},
which we conveniently ignore) that have a 0 minimum
also allow a single occurrence.</p></td><td class="code"><div class="highlight"><pre>                        <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">([</span><span class="bp">None</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>Anything else is a literal.</p></td><td class="code"><div class="highlight"><pre>                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">consume_next</span><span class="p">:</span>
                <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">pattern_iter</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">consume_next</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>A case of using the disjunctive form. No results for you!</p></td><td class="code"><div class="highlight"><pre>        <span class="k">return</span> <span class="nb">zip</span><span class="p">([</span><span class="s">&#39;&#39;</span><span class="p">],</span>  <span class="p">[[]])</span>

    <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">flatten_result</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">next_char</span><span class="p">(</span><span class="n">input_iter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An iterator that yields the next character from &quot;pattern_iter&quot;, respecting</span>
<span class="sd">    escape sequences. An escaped character is replaced by a representative of</span>
<span class="sd">    its class (e.g. \w -&gt; &quot;x&quot;). If the escaped character is one that is</span>
<span class="sd">    skipped, it is not returned (the next character is returned instead).</span>

<span class="sd">    Yields the next character, along with a boolean indicating whether it is a</span>
<span class="sd">    raw (unescaped) character or not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">input_iter</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="o">!=</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">&#39;</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">ch</span><span class="p">,</span> <span class="bp">False</span>
            <span class="k">continue</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">input_iter</span><span class="p">)</span>
        <span class="n">representative</span> <span class="o">=</span> <span class="n">ESCAPE_MAPPINGS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">representative</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">yield</span> <span class="n">representative</span><span class="p">,</span> <span class="bp">True</span>

<span class="k">def</span> <span class="nf">walk_to_end</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">input_iter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The iterator is currently inside a capturing group. We want to walk to the</span>
<span class="sd">    close of this group, skipping over any nested groups and handling escaped</span>
<span class="sd">    parentheses correctly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;(&#39;</span><span class="p">:</span>
        <span class="n">nesting</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nesting</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="ow">in</span> <span class="n">input_iter</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">escaped</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">nesting</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;)&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">nesting</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">nesting</span> <span class="o">-=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">get_quantifier</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">input_iter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse a quantifier from the input, where &quot;ch&quot; is the first character in the</span>
<span class="sd">    quantifier.</span>

<span class="sd">    Returns the minimum number of occurences permitted by the quantifier and</span>
<span class="sd">    either None or the next character from the input_iter if the next character</span>
<span class="sd">    is not part of the quantifier.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="s">&#39;*?+&#39;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ch2</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">input_iter</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">ch2</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">ch2</span> <span class="o">==</span> <span class="s">&#39;?&#39;</span><span class="p">:</span>
            <span class="n">ch2</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;+&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ch2</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ch2</span>

    <span class="n">quant</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">ch</span> <span class="o">!=</span> <span class="s">&#39;}&#39;</span><span class="p">:</span>
        <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">input_iter</span><span class="p">)</span>
        <span class="n">quant</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
    <span class="n">quant</span> <span class="o">=</span> <span class="n">quant</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">quant</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>Consume the trailing '?', if necessary.</p></td><td class="code"><div class="highlight"><pre>    <span class="k">try</span><span class="p">:</span>
        <span class="n">ch</span><span class="p">,</span> <span class="n">escaped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">input_iter</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s">&#39;?&#39;</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ch</span>

<span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the &quot;source&quot; contains an instance of &quot;inst&quot;. False,</span>
<span class="sd">    otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">NonCapture</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">contains</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">flatten_result</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Turns the given source sequence into a list of reg-exp possibilities and</span>
<span class="sd">    their arguments. Returns a list of strings and a list of argument lists.</span>
<span class="sd">    Each of the two lists will be of the same length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">],</span> <span class="p">[[]]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">params</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
    <span class="n">result_args</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">piece</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">last</span><span class="p">:</span><span class="n">pos</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">Group</span><span class="p">):</span>
            <span class="n">piece</span> <span class="o">+=</span> <span class="n">elt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">elt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">piece</span>
            <span class="k">if</span> <span class="n">param</span><span class="p">:</span>
                <span class="n">result_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="p">(</span><span class="n">Choice</span><span class="p">,</span> <span class="n">NonCapture</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">NonCapture</span><span class="p">):</span>
                <span class="n">elt</span> <span class="o">=</span> <span class="p">[</span><span class="n">elt</span><span class="p">]</span>
            <span class="n">inner_result</span><span class="p">,</span> <span class="n">inner_args</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">elt</span><span class="p">:</span>
                <span class="n">res</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">flatten_result</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="n">inner_result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
                <span class="n">inner_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">new_result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">args</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result_args</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i_item</span><span class="p">,</span> <span class="n">i_args</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">inner_result</span><span class="p">,</span> <span class="n">inner_args</span><span class="p">):</span>
                    <span class="n">new_result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span> <span class="o">+</span> <span class="n">i_item</span><span class="p">)</span>
                    <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args</span><span class="p">[:]</span> <span class="o">+</span> <span class="n">i_args</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">new_result</span>
            <span class="n">result_args</span> <span class="o">=</span> <span class="n">new_args</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">last</span><span class="p">:</span>
        <span class="n">piece</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="n">last</span><span class="p">:])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">piece</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">result_args</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/django",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
