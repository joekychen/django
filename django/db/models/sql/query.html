<!DOCTYPE html>
<html><head><title>joekychen/django » django › db › models › sql › query.py

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../../index.html"></a><h1>query.py</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Create SQL statements for QuerySets.</span>

<span class="sd">The code in here encapsulates all of the SQL construction so that QuerySets</span>
<span class="sd">themselves do not have to (and could be backed by things other than SQL</span>
<span class="sd">databases). The abstraction barrier only works one way: this module has to know</span>
<span class="sd">all about the internals of models in order to get the information it needs.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">django.utils.datastructures</span> <span class="kn">import</span> <span class="n">SortedDict</span>
<span class="kn">from</span> <span class="nn">django.utils.encoding</span> <span class="kn">import</span> <span class="n">force_unicode</span>
<span class="kn">from</span> <span class="nn">django.utils.tree</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">connections</span><span class="p">,</span> <span class="n">DEFAULT_DB_ALIAS</span>
<span class="kn">from</span> <span class="nn">django.db.models</span> <span class="kn">import</span> <span class="n">signals</span>
<span class="kn">from</span> <span class="nn">django.db.models.expressions</span> <span class="kn">import</span> <span class="n">ExpressionNode</span>
<span class="kn">from</span> <span class="nn">django.db.models.fields</span> <span class="kn">import</span> <span class="n">FieldDoesNotExist</span>
<span class="kn">from</span> <span class="nn">django.db.models.query_utils</span> <span class="kn">import</span> <span class="n">InvalidQuery</span>
<span class="kn">from</span> <span class="nn">django.db.models.sql</span> <span class="kn">import</span> <span class="n">aggregates</span> <span class="k">as</span> <span class="n">base_aggregates_module</span>
<span class="kn">from</span> <span class="nn">django.db.models.sql.constants</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">django.db.models.sql.datastructures</span> <span class="kn">import</span> <span class="n">EmptyResultSet</span><span class="p">,</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">MultiJoin</span>
<span class="kn">from</span> <span class="nn">django.db.models.sql.expressions</span> <span class="kn">import</span> <span class="n">SQLEvaluator</span>
<span class="kn">from</span> <span class="nn">django.db.models.sql.where</span> <span class="kn">import</span> <span class="p">(</span><span class="n">WhereNode</span><span class="p">,</span> <span class="n">Constraint</span><span class="p">,</span> <span class="n">EverythingNode</span><span class="p">,</span>
    <span class="n">ExtraWhere</span><span class="p">,</span> <span class="n">AND</span><span class="p">,</span> <span class="n">OR</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">django.core.exceptions</span> <span class="kn">import</span> <span class="n">FieldError</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Query&#39;</span><span class="p">,</span> <span class="s">&#39;RawQuery&#39;</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">RawQuery</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single raw SQL query</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sql</span><span class="p">,</span> <span class="n">using</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sql</span> <span class="o">=</span> <span class="n">sql</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">using</span> <span class="o">=</span> <span class="n">using</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="bp">None</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Mirror some properties of a normal query so that
the compiler can be used to process results.</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span>  <span class="c"># Used for offset/limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_select</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">using</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RawQuery</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql</span><span class="p">,</span> <span class="n">using</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the database-returned value into a type that is consistent</span>
<span class="sd">        across database backends.</span>

<span class="sd">        By default, this defers to the underlying backend operations, but</span>
<span class="sd">        it can be overridden by Query classes for specific backends.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">convert_values</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_execute_query</span><span class="p">()</span>
        <span class="n">converter</span> <span class="o">=</span> <span class="n">connections</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">using</span><span class="p">]</span><span class="o">.</span><span class="n">introspection</span><span class="o">.</span><span class="n">table_name_converter</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">converter</span><span class="p">(</span><span class="n">column_meta</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">column_meta</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">description</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Always execute a new query for a new iterator.
This could be optimized with a cache at the expense of RAM.</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">_execute_query</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">connections</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">using</span><span class="p">]</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">can_use_chunked_reads</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>If the database can't use chunked reads we need to make sure we
evaluate the entire query up front.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;&lt;RawQuery: </span><span class="si">%r</span><span class="s">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_execute_query</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span> <span class="o">=</span> <span class="n">connections</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">using</span><span class="p">]</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sql</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Query</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single SQL query.</span>
<span class="sd">    &quot;&quot;&quot;</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>SQL join types. These are part of the class because their string forms
vary from database to database and can be customised by a subclass.</p></td><td class="code"><div class="highlight"><pre>    <span class="n">INNER</span> <span class="o">=</span> <span class="s">&#39;INNER JOIN&#39;</span>
    <span class="n">LOUTER</span> <span class="o">=</span> <span class="s">&#39;LEFT OUTER JOIN&#39;</span>

    <span class="n">alias_prefix</span> <span class="o">=</span> <span class="s">&#39;T&#39;</span>
    <span class="n">query_terms</span> <span class="o">=</span> <span class="n">QUERY_TERMS</span>
    <span class="n">aggregates_module</span> <span class="o">=</span> <span class="n">base_aggregates_module</span>

    <span class="n">compiler</span> <span class="o">=</span> <span class="s">&#39;SQLCompiler&#39;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">WhereNode</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">()</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>alias_map is the most important data structure regarding joins.
It's used for recording which joins exist in the query and what
type they are. The key is the alias of the joined table (possibly
the table name) and the value is JoinInfo from constants.py.</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table_map</span> <span class="o">=</span> <span class="p">{}</span>     <span class="c"># Maps table names to list of aliases.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">join_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_cols</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_ordering</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standard_ordering</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ordering_aliases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">related_select_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dupe_avoidance</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used_aliases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_is_sticky</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">included_inherited_models</span> <span class="o">=</span> <span class="p">{}</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>SQL-related attributes</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tables</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c"># Aliases in the order they are created.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">where</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where_class</span> <span class="o">=</span> <span class="n">where</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">having</span> <span class="o">=</span> <span class="n">where</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span>  <span class="c"># Used for offset/limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distinct</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distinct_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_for_update</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_for_update_nowait</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_related</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">related_select_cols</span> <span class="o">=</span> <span class="p">[]</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>SQL aggregate-related attributes</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">()</span> <span class="c"># Maps alias -&gt; SQL aggregate function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select_mask</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_select_cache</span> <span class="o">=</span> <span class="bp">None</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>Arbitrary maximum limit for select<em>related. Prevents infinite
recursion. Can be changed by the depth parameter to select</em>related().</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="mi">5</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>These are for extensions. The contents are more or less appended
verbatim to the appropriate clause.</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">extra</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">()</span>  <span class="c"># Maps col_alias -&gt; (col_sql, params).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_select_mask</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extra_select_cache</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extra_tables</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_order_by</span> <span class="o">=</span> <span class="p">()</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>A tuple that is a set of model field names and either True, if these
are the fields to defer, or False if these are the only fields to
load.</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(),</span> <span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the query as a string of SQL with the parameter values</span>
<span class="sd">        substituted in (use sql_with_params() to see the unsubstituted string).</span>

<span class="sd">        Parameter values won&#39;t necessarily be quoted correctly, since that is</span>
<span class="sd">        done by the database interface at execution time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sql</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sql_with_params</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sql</span> <span class="o">%</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">sql_with_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the query as an SQL string and the parameters that will be</span>
<span class="sd">        subsituted into the query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_compiler</span><span class="p">(</span><span class="n">DEFAULT_DB_ALIAS</span><span class="p">)</span><span class="o">.</span><span class="n">as_sql</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pickling support.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj_dict</span><span class="p">[</span><span class="s">&#39;related_select_fields&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj_dict</span><span class="p">[</span><span class="s">&#39;related_select_cols&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>Fields can't be pickled, so if a field list has been
specified, we pickle the list of field names instead.
None is also a possible value; that can pass as-is</p></td><td class="code"><div class="highlight"><pre>        <span class="n">obj_dict</span><span class="p">[</span><span class="s">&#39;select_fields&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">obj_dict</span><span class="p">[</span><span class="s">&#39;select_fields&#39;</span><span class="p">]</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">obj_dict</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpickling support.</span>
<span class="sd">        &quot;&quot;&quot;</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>Rebuild list of field instances</p></td><td class="code"><div class="highlight"><pre>        <span class="n">opts</span> <span class="o">=</span> <span class="n">obj_dict</span><span class="p">[</span><span class="s">&#39;model&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">_meta</span>
        <span class="n">obj_dict</span><span class="p">[</span><span class="s">&#39;select_fields&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">None</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">obj_dict</span><span class="p">[</span><span class="s">&#39;select_fields&#39;</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">obj_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">get_compiler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">using</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">using</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">connection</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Need either using or connection&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">using</span><span class="p">:</span>
            <span class="n">connection</span> <span class="o">=</span> <span class="n">connections</span><span class="p">[</span><span class="n">using</span><span class="p">]</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>Check that the compiler will be able to execute the query</p></td><td class="code"><div class="highlight"><pre>        <span class="k">for</span> <span class="n">alias</span><span class="p">,</span> <span class="n">aggregate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">check_aggregate_support</span><span class="p">(</span><span class="n">aggregate</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">compiler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compiler</span><span class="p">)(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">using</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_meta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Options instance (the model._meta) from which to start</span>
<span class="sd">        processing. Normally, this is self.model._meta, but it can be changed</span>
<span class="sd">        by subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_meta</span>

    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the current instance. The &#39;kwargs&#39; parameter can be</span>
<span class="sd">        used by clients to update attributes after copying has taken place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">__class__</span> <span class="o">=</span> <span class="n">klass</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">alias_refcount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">alias_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">table_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">join_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">default_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_cols</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">default_ordering</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_ordering</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">standard_ordering</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standard_ordering</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">included_inherited_models</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_inherited_models</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">ordering_aliases</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">select_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_fields</span><span class="p">[:]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">related_select_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">related_select_fields</span><span class="p">[:]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">dupe_avoidance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dupe_avoidance</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">[:]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">[:]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">where</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">where_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where_class</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">group_by</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">group_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span><span class="p">[:]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">having</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">having</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">[:]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">low_mark</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">high_mark</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">distinct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distinct</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">distinct_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distinct_fields</span><span class="p">[:]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">select_for_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_for_update</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">select_for_update_nowait</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_for_update_nowait</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">select_related</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_related</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">related_select_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">aggregates</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select_mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">aggregate_select_mask</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">aggregate_select_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p><em>aggregate</em>select<em>cache cannot be copied, as doing so breaks the
(necessary) state in which both aggregates and
_aggregate</em>select_cache point to the same underlying objects.
It will get re-populated in the cloned queryset the next time it's
used.</p></td><td class="code"><div class="highlight"><pre>        <span class="n">obj</span><span class="o">.</span><span class="n">_aggregate_select_cache</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">max_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_depth</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">extra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_select_mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">extra_select_mask</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">extra_select_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_select_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_select_cache</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_extra_select_cache</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_extra_select_cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_select_cache</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">extra_tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_tables</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">extra_order_by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_order_by</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">deferred_loading</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="n">memo</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_is_sticky</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_aliases</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">used_aliases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_aliases</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">used_aliases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">filter_is_sticky</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;_setup_query&#39;</span><span class="p">):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_setup_query</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">convert_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert the database-returned value into a type that is consistent</span>
<span class="sd">        across database backends.</span>

<span class="sd">        By default, this defers to the underlying backend operations, but</span>
<span class="sd">        it can be overridden by Query classes for specific backends.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">convert_values</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resolve_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resolve the value of aggregates returned by the database to</span>
<span class="sd">        consistent (and reasonable) types.</span>

<span class="sd">        This is required because of the predisposition of certain backends</span>
<span class="sd">        to return Decimal and long types when they are not needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">is_ordinal</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>Return None as-is</p></td><td class="code"><div class="highlight"><pre>            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">is_ordinal</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>Any ordinal aggregate (e.g., count) returns an int</p></td><td class="code"><div class="highlight"><pre>            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">is_computed</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>Any computed aggregate (e.g., avg) returns a float</p></td><td class="code"><div class="highlight"><pre>            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>Return value depends on the type of the field being processed.</p></td><td class="code"><div class="highlight"><pre>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_values</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">field</span><span class="p">,</span> <span class="n">connection</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_aggregation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">using</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the dictionary with the values of the existing aggregations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>If there is a group by clause, aggregating does not add useful
information but retrieves only the first row. Aggregate
over the subquery instead.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">django.db.models.sql.subqueries</span> <span class="kn">import</span> <span class="n">AggregateQuery</span>
            <span class="n">query</span> <span class="o">=</span> <span class="n">AggregateQuery</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>Remove any aggregates marked for reduction from the subquery
and move them to the outer AggregateQuery.</p></td><td class="code"><div class="highlight"><pre>            <span class="k">for</span> <span class="n">alias</span><span class="p">,</span> <span class="n">aggregate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">is_summary</span><span class="p">:</span>
                    <span class="n">query</span><span class="o">.</span><span class="n">aggregate_select</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">aggregate</span>
                    <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">aggregate_select</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">query</span><span class="o">.</span><span class="n">add_subquery</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">using</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">EmptyResultSet</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">aggregate_select</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_cols</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extra</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_inherited_models</span><span class="p">()</span>

        <span class="n">query</span><span class="o">.</span><span class="n">clear_ordering</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">query</span><span class="o">.</span><span class="n">clear_limits</span><span class="p">()</span>
        <span class="n">query</span><span class="o">.</span><span class="n">select_for_update</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">query</span><span class="o">.</span><span class="n">select_related</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">query</span><span class="o">.</span><span class="n">related_select_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">query</span><span class="o">.</span><span class="n">related_select_fields</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">get_compiler</span><span class="p">(</span><span class="n">using</span><span class="p">)</span><span class="o">.</span><span class="n">execute_sql</span><span class="p">(</span><span class="n">SINGLE</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">query</span><span class="o">.</span><span class="n">aggregate_select</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">([</span>
            <span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve_aggregate</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="n">connections</span><span class="p">[</span><span class="n">using</span><span class="p">]))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">),</span> <span class="n">val</span>
            <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">aggregate_select</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">result</span><span class="p">)</span>
        <span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">using</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a COUNT() query using the current filter constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distinct</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">distinct_fields</span><span class="p">):</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>If a select clause exists, then the query has already started to
specify the columns that are to be returned.
In this case, we need to use a subquery to evaluate the count.</p></td><td class="code"><div class="highlight"><pre>            <span class="kn">from</span> <span class="nn">django.db.models.sql.subqueries</span> <span class="kn">import</span> <span class="n">AggregateQuery</span>
            <span class="n">subquery</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="n">subquery</span><span class="o">.</span><span class="n">clear_ordering</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">subquery</span><span class="o">.</span><span class="n">clear_limits</span><span class="p">()</span>

            <span class="n">obj</span> <span class="o">=</span> <span class="n">AggregateQuery</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">add_subquery</span><span class="p">(</span><span class="n">subquery</span><span class="p">,</span> <span class="n">using</span><span class="o">=</span><span class="n">using</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">EmptyResultSet</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>add_subquery evaluates the query, if it's an EmptyResultSet
then there are can be no results, and therefore there the
count is obviously 0</p></td><td class="code"><div class="highlight"><pre>                <span class="k">return</span> <span class="mi">0</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">add_count_column</span><span class="p">()</span>
        <span class="n">number</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_aggregation</span><span class="p">(</span><span class="n">using</span><span class="o">=</span><span class="n">using</span><span class="p">)[</span><span class="bp">None</span><span class="p">]</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>Apply offset and limit constraints manually, since using LIMIT/OFFSET
in SQL (in variants that provide them) doesn't change the COUNT
output.</p></td><td class="code"><div class="highlight"><pre>        <span class="n">number</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">number</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">number</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">number</span>

    <span class="k">def</span> <span class="nf">has_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">using</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">q</span><span class="o">.</span><span class="n">add_extra</span><span class="p">({</span><span class="s">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span><span class="o">.</span><span class="n">select_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span><span class="o">.</span><span class="n">default_cols</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">q</span><span class="o">.</span><span class="n">select_related</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">q</span><span class="o">.</span><span class="n">set_extra_mask</span><span class="p">((</span><span class="s">&#39;a&#39;</span><span class="p">,))</span>
        <span class="n">q</span><span class="o">.</span><span class="n">set_aggregate_mask</span><span class="p">(())</span>
        <span class="n">q</span><span class="o">.</span><span class="n">clear_ordering</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">set_limits</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">compiler</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get_compiler</span><span class="p">(</span><span class="n">using</span><span class="o">=</span><span class="n">using</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">compiler</span><span class="o">.</span><span class="n">execute_sql</span><span class="p">(</span><span class="n">SINGLE</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">connector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge the &#39;rhs&#39; query into the current one (with any &#39;rhs&#39; effects</span>
<span class="sd">        being applied *after* (that is, &quot;to the right of&quot;) anything in the</span>
<span class="sd">        current query. &#39;rhs&#39; is not modified during a call to this function.</span>

<span class="sd">        The &#39;connector&#39; parameter describes how to connect filters from the</span>
<span class="sd">        &#39;rhs&#39; query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> \
                <span class="s">&quot;Cannot combine queries on two different base models.&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_filter</span><span class="p">(),</span> \
                <span class="s">&quot;Cannot combine queries once a slice has been taken.&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">distinct</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">distinct</span><span class="p">,</span> \
            <span class="s">&quot;Cannot combine a unique query with a non-unique query.&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">distinct_fields</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">distinct_fields</span><span class="p">,</span> \
            <span class="s">&quot;Cannot combine queries with different distinct fields.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_inherited_models</span><span class="p">()</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>Work out how to relabel the rhs aliases, if necessary.</p></td><td class="code"><div class="highlight"><pre>        <span class="n">change_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">used</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">conjunction</span> <span class="o">=</span> <span class="p">(</span><span class="n">connector</span> <span class="o">==</span> <span class="n">AND</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>Add the joins in the rhs query into the new query.</p></td><td class="code"><div class="highlight"><pre>        <span class="n">first</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">rhs</span><span class="o">.</span><span class="n">tables</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">rhs</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">alias</span><span class="p">]:</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>An unused alias.</p></td><td class="code"><div class="highlight"><pre>                <span class="k">continue</span>
            <span class="n">table</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">join_type</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_col</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span>
            <span class="n">promote</span> <span class="o">=</span> <span class="n">join_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOUTER</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>If the left side of the join was already relabeled, use the
updated alias.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">lhs</span> <span class="o">=</span> <span class="n">change_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs</span><span class="p">)</span>
            <span class="n">new_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">lhs</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">lhs_col</span><span class="p">,</span> <span class="n">col</span><span class="p">),</span>
                    <span class="n">conjunction</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">first</span><span class="p">,</span> <span class="n">used</span><span class="p">,</span> <span class="n">promote</span><span class="p">,</span> <span class="ow">not</span> <span class="n">conjunction</span><span class="p">)</span>
            <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_alias</span><span class="p">)</span>
            <span class="n">change_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_alias</span>
            <span class="n">first</span> <span class="o">=</span> <span class="bp">False</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>So that we don't exclude valid results in an "or" query combination,
all joins exclusive to either the lhs or the rhs must be converted
to an outer join.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="ow">not</span> <span class="n">conjunction</span><span class="p">:</span>
            <span class="n">l_tables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">)</span>
            <span class="n">r_tables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">tables</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>Update r_tables aliases.</p></td><td class="code"><div class="highlight"><pre>            <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">change_map</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">r_tables</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>r_tables may contain entries that have a refcount of 0
if the query has references to a table that can be
trimmed because only the foreign key is used.
We only need to fix the aliases for the tables that
actually have aliases.</p></td><td class="code"><div class="highlight"><pre>                    <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">alias</span><span class="p">]:</span>
                        <span class="n">r_tables</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                        <span class="n">r_tables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">change_map</span><span class="p">[</span><span class="n">alias</span><span class="p">])</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>Find aliases that are exclusive to rhs or lhs.
These are promoted to outer joins.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">outer_tables</span> <span class="o">=</span> <span class="p">(</span><span class="n">l_tables</span> <span class="o">|</span> <span class="n">r_tables</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">l_tables</span> <span class="o">&amp;</span> <span class="n">r_tables</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">outer_tables</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>Again, some of the tables won't have aliases due to
the trimming of unnecessary tables.</p></td><td class="code"><div class="highlight"><pre>                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span> <span class="ow">or</span> <span class="n">rhs</span><span class="o">.</span><span class="n">alias_refcount</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">alias</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>Now relabel a copy of the rhs where-clause and add it to the current
one.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">where</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">where</span><span class="p">)</span>
            <span class="n">w</span><span class="o">.</span><span class="n">relabel_aliases</span><span class="p">(</span><span class="n">change_map</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>Since 'self' matches everything, add an explicit "include
everything" where-constraint so that connections between the
where clauses won't exclude valid results.</p></td><td class="code"><div class="highlight"><pre>                <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">EverythingNode</span><span class="p">(),</span> <span class="n">AND</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><p>rhs has an empty where clause.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where_class</span><span class="p">()</span>
            <span class="n">w</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">EverythingNode</span><span class="p">(),</span> <span class="n">AND</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where_class</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">connector</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><p>Selection columns and extra extensions are those provided by 'rhs'.</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">rhs</span><span class="o">.</span><span class="n">select</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">change_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">item</span><span class="o">.</span><span class="n">relabel_aliases</span><span class="p">(</span><span class="n">change_map</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_fields</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">select_fields</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="n">connector</span> <span class="o">==</span> <span class="n">OR</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><p>It would be nice to be able to handle this, but the queries don't
really make sense (or return consistent value sets). Not worth
the extra complexity when you can write a real query instead.</p></td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span> <span class="ow">and</span> <span class="n">rhs</span><span class="o">.</span><span class="n">extra</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;When merging querysets using &#39;or&#39;, you &quot;</span>
                        <span class="s">&quot;cannot have extra(select=...) on both sides.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">extra</span><span class="p">)</span>
        <span class="n">extra_select_mask</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_select_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">extra_select_mask</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extra_select_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="o">.</span><span class="n">extra_select_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">extra_select_mask</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">extra_select_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extra_select_mask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_extra_mask</span><span class="p">(</span><span class="n">extra_select_mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_tables</span> <span class="o">+=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">extra_tables</span></pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>Ordering uses the 'rhs' ordering, unless it has none, in which case
the current ordering is used.</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">order_by</span> <span class="ow">and</span> <span class="n">rhs</span><span class="o">.</span><span class="n">order_by</span><span class="p">[:]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_order_by</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">extra_order_by</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_order_by</span>

    <span class="k">def</span> <span class="nf">deferred_to_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the self.deferred_loading data structure to an alternate data</span>
<span class="sd">        structure, describing the field that *will* be loaded. This is used to</span>
<span class="sd">        compute the columns to select from the database and also by the</span>
<span class="sd">        QuerySet class to work out which fields are being initialised on each</span>
<span class="sd">        model. Models that have all their fields included aren&#39;t mentioned in</span>
<span class="sd">        the result, only those that have field restrictions in place.</span>

<span class="sd">        The &quot;target&quot; parameter is the instance that is populated (in place).</span>
<span class="sd">        The &quot;callback&quot; is a function that is called whenever a (model, field)</span>
<span class="sd">        pair need to be added to &quot;target&quot;. It accepts three parameters:</span>
<span class="sd">        &quot;target&quot;, and the model and list of fields being added for that model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">field_names</span><span class="p">,</span> <span class="n">defer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">field_names</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">orig_opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_meta</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">must_include</span> <span class="o">=</span> <span class="p">{</span><span class="n">orig_opts</span><span class="o">.</span><span class="n">concrete_model</span><span class="p">:</span> <span class="nb">set</span><span class="p">([</span><span class="n">orig_opts</span><span class="o">.</span><span class="n">pk</span><span class="p">])}</span>
        <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">field_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">LOOKUP_SEP</span><span class="p">)</span>
            <span class="n">cur_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
            <span class="n">opts</span> <span class="o">=</span> <span class="n">orig_opts</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">old_model</span> <span class="o">=</span> <span class="n">cur_model</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span><span class="n">name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cur_model</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">rel</span><span class="o">.</span><span class="n">to</span>
                <span class="n">opts</span> <span class="o">=</span> <span class="n">cur_model</span><span class="o">.</span><span class="n">_meta</span></pre></div></td></tr>


<tr id="section-40"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-40">&#182;</a></div><p>Even if we're "just passing through" this model, we must add
both the current model's pk and the related reference field
to the things we select.</p></td><td class="code"><div class="highlight"><pre>                <span class="n">must_include</span><span class="p">[</span><span class="n">old_model</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
                <span class="n">add_to_dict</span><span class="p">(</span><span class="n">must_include</span><span class="p">,</span> <span class="n">cur_model</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">pk</span><span class="p">)</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">model</span> <span class="o">=</span> <span class="n">cur_model</span>
            <span class="n">add_to_dict</span><span class="p">(</span><span class="n">seen</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">defer</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-41"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-41">&#182;</a></div><p>We need to load all fields for each model, except those that
appear in "seen" (for all models that appear in "seen"). The only
slight complexity here is handling fields that exist on parent
models.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">workset</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">model</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">seen</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">get_fields_with_model</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">add_to_dict</span><span class="p">(</span><span class="n">workset</span><span class="p">,</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">model</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">model</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">must_include</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span></pre></div></td></tr>


<tr id="section-42"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-42">&#182;</a></div><p>If we haven't included a model in workset, we don't add the
corresponding must_include fields for that model, since an
empty set means "include all fields". That's why there's no
"else" branch here.</p></td><td class="code"><div class="highlight"><pre>                <span class="k">if</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">workset</span><span class="p">:</span>
                    <span class="n">workset</span><span class="p">[</span><span class="n">model</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">model</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">workset</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">callback</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">model</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">must_include</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">seen</span><span class="p">[</span><span class="n">model</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-43"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-43">&#182;</a></div><p>As we've passed through this model, but not explicitly
included any fields, we have to make sure it's mentioned
so that only the "must include" fields are pulled in.</p></td><td class="code"><div class="highlight"><pre>                    <span class="n">seen</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span></pre></div></td></tr>


<tr id="section-44"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-44">&#182;</a></div><p>Now ensure that every model in the inheritance chain is mentioned
in the parent list. Again, it must be mentioned to ensure that
only "must include" fields are pulled in.</p></td><td class="code"><div class="highlight"><pre>            <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">orig_opts</span><span class="o">.</span><span class="n">get_parent_list</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">seen</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">model</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">seen</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">callback</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">deferred_to_columns_cb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback used by deferred_to_columns(). The &quot;target&quot; parameter should</span>
<span class="sd">        be a set instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">db_table</span>
        <span class="k">if</span> <span class="n">table</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">target</span><span class="p">[</span><span class="n">table</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">target</span><span class="p">[</span><span class="n">table</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">table_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a table alias for the given table_name and whether this is a</span>
<span class="sd">        new alias or not.</span>

<span class="sd">        If &#39;create&#39; is true, a new alias is always created. Otherwise, the</span>
<span class="sd">        most recently created alias for the table (if one exists) is reused.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">create</span> <span class="ow">and</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">alias</span><span class="p">,</span> <span class="bp">False</span></pre></div></td></tr>


<tr id="section-45"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-45">&#182;</a></div><p>Create a new alias for this table.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alias_prefix</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">current</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-46"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-46">&#182;</a></div><p>The first occurence of a table uses the table name directly.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">alias</span> <span class="o">=</span> <span class="n">table_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">table_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">alias</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">alias</span><span class="p">,</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">ref_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Increases the reference count for this alias. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">unref_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Decreases the reference count for this alias. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">-=</span> <span class="n">amount</span>

    <span class="k">def</span> <span class="nf">promote_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">unconditional</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Promotes the join type of an alias to an outer join if it&#39;s possible</span>
<span class="sd">        for the join to contain NULL values on the left. If &#39;unconditional&#39; is</span>
<span class="sd">        False, the join is only promoted if it is nullable, otherwise it is</span>
<span class="sd">        always promoted.</span>

<span class="sd">        Returns True if the join was promoted by this call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">unconditional</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span><span class="o">.</span><span class="n">nullable</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span><span class="o">.</span><span class="n">join_type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOUTER</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">join_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">LOUTER</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">promote_alias_chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="n">must_promote</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Walks along a chain of aliases, promoting the first nullable join and</span>
<span class="sd">        any joins following that. If &#39;must_promote&#39; is True, all the aliases in</span>
<span class="sd">        the chain are promoted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">must_promote</span><span class="p">):</span>
                <span class="n">must_promote</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">reset_refcounts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_counts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method will reset reference counts for aliases so that they match</span>
<span class="sd">        the value passed in :param to_counts:.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">alias</span><span class="p">,</span> <span class="n">cur_refcount</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">unref_amount</span> <span class="o">=</span> <span class="n">cur_refcount</span> <span class="o">-</span> <span class="n">to_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unref_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">unref_amount</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">promote_unused_aliases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_refcounts</span><span class="p">,</span> <span class="n">used_aliases</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a &quot;before&quot; copy of the alias_refcounts dictionary (as</span>
<span class="sd">        &#39;initial_refcounts&#39;) and a collection of aliases that may have been</span>
<span class="sd">        changed or created, works out which aliases have been created since</span>
<span class="sd">        then and which ones haven&#39;t been used and promotes all of those</span>
<span class="sd">        aliases, plus any children of theirs in the alias tree, to outer joins.</span>
<span class="sd">        &quot;&quot;&quot;</span></pre></div></td></tr>


<tr id="section-47"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-47">&#182;</a></div><p>FIXME: There's some (a lot of!) overlap with the similar OR promotion
in add_filter(). It's not quite identical, but is very similar. So
pulling out the common bits is something for later.</p></td><td class="code"><div class="highlight"><pre>        <span class="n">considered</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">alias</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used_aliases</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">alias</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">initial_refcounts</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">==</span> <span class="n">initial_refcounts</span><span class="p">[</span><span class="n">alias</span><span class="p">]):</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span><span class="o">.</span><span class="n">lhs_alias</span>
                <span class="n">must_promote</span> <span class="o">=</span> <span class="n">considered</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
                <span class="n">promoted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">must_promote</span><span class="p">)</span>
                <span class="n">considered</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">must_promote</span> <span class="ow">or</span> <span class="n">promoted</span>

    <span class="k">def</span> <span class="nf">change_aliases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">change_map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the aliases in change_map (which maps old-alias -&gt; new-alias),</span>
<span class="sd">        relabelling any references to them in select columns and the where</span>
<span class="sd">        clause.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">change_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">change_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">()</span></pre></div></td></tr>


<tr id="section-48"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-48">&#182;</a></div><ol>
<li>Update references in "select" (normal columns plus aliases),
"group by", "where" and "having".</li>
</ol></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">relabel_aliases</span><span class="p">(</span><span class="n">change_map</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">having</span><span class="o">.</span><span class="n">relabel_aliases</span><span class="p">(</span><span class="n">change_map</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">columns</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span> <span class="ow">or</span> <span class="p">[]]:</span>
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                    <span class="n">old_alias</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">columns</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">change_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">old_alias</span><span class="p">,</span> <span class="n">old_alias</span><span class="p">),</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">relabel_aliases</span><span class="p">(</span><span class="n">change_map</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">mapping</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                    <span class="n">old_alias</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">change_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">old_alias</span><span class="p">,</span> <span class="n">old_alias</span><span class="p">),</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">relabel_aliases</span><span class="p">(</span><span class="n">change_map</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-49"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-49">&#182;</a></div><ol>
<li>Rename the alias in the internal table/alias datastructures.</li>
</ol></td><td class="code"><div class="highlight"><pre>        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">aliases</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">aliases</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">change_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">aliases</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">join_map</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">aliases</span>
        <span class="k">for</span> <span class="n">old_alias</span><span class="p">,</span> <span class="n">new_alias</span> <span class="ow">in</span> <span class="n">change_map</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">alias_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">old_alias</span><span class="p">]</span>
            <span class="n">alias_data</span> <span class="o">=</span> <span class="n">alias_data</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">rhs_alias</span><span class="o">=</span><span class="n">new_alias</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">new_alias</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">old_alias</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">old_alias</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">new_alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">alias_data</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">old_alias</span><span class="p">]</span>

            <span class="n">table_aliases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_map</span><span class="p">[</span><span class="n">alias_data</span><span class="o">.</span><span class="n">table_name</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">alias</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">table_aliases</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">alias</span> <span class="o">==</span> <span class="n">old_alias</span><span class="p">:</span>
                    <span class="n">table_aliases</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_alias</span>
                    <span class="k">break</span>
            <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">alias</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">alias</span> <span class="o">==</span> <span class="n">old_alias</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_alias</span>
                    <span class="k">break</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_inherited_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">change_map</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">included_inherited_models</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">change_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span></pre></div></td></tr>


<tr id="section-50"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-50">&#182;</a></div><ol>
<li>Update any joins that refer to the old alias.</li>
</ol></td><td class="code"><div class="highlight"><pre>        <span class="k">for</span> <span class="n">alias</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">lhs_alias</span>
            <span class="k">if</span> <span class="n">lhs</span> <span class="ow">in</span> <span class="n">change_map</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_replace</span><span class="p">(</span><span class="n">lhs_alias</span><span class="o">=</span><span class="n">change_map</span><span class="p">[</span><span class="n">lhs</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">bump_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exceptions</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the alias prefix to the next letter in the alphabet and</span>
<span class="sd">        relabels all the aliases. Even tables that previously had no alias will</span>
<span class="sd">        get an alias after this call (it&#39;s mostly used for nested queries and</span>
<span class="sd">        the outer query will already be using the non-aliased table name).</span>

<span class="sd">        Subclasses who create their own prefix should override this method to</span>
<span class="sd">        produce a similar result (a new prefix and relabelled aliases).</span>

<span class="sd">        The &#39;exceptions&#39; parameter is a container that holds alias names which</span>
<span class="sd">        should not be changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alias_prefix</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&#39;Z&#39;</span><span class="p">)</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">current</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias_prefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="n">change_map</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">alias</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">exceptions</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new_alias</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="n">change_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_alias</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_alias</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">change_aliases</span><span class="p">(</span><span class="n">change_map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_initial_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first alias for this query, after increasing its reference</span>
<span class="sd">        count.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">db_table</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">alias</span>

    <span class="k">def</span> <span class="nf">count_active_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of tables in this query with a non-zero reference</span>
<span class="sd">        count. Note that after execution, the reference counts are zeroed, so</span>
<span class="sd">        tables added in compiler will not be seen by this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="mi">1</span> <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">always_create</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">exclusions</span><span class="o">=</span><span class="p">(),</span>
            <span class="n">promote</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">outer_if_first</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">reuse</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an alias for the join in &#39;connection&#39;, either reusing an</span>
<span class="sd">        existing alias for that join or creating a new one. &#39;connection&#39; is a</span>
<span class="sd">        tuple (lhs, table, lhs_col, col) where &#39;lhs&#39; is either an existing</span>
<span class="sd">        table alias or a table name. The join correspods to the SQL equivalent</span>
<span class="sd">        of::</span>

<span class="sd">            lhs.lhs_col = table.col</span>

<span class="sd">        If &#39;always_create&#39; is True and &#39;reuse&#39; is None, a new alias is always</span>
<span class="sd">        created, regardless of whether one already exists or not. If</span>
<span class="sd">        &#39;always_create&#39; is True and &#39;reuse&#39; is a set, an alias in &#39;reuse&#39; that</span>
<span class="sd">        matches the connection will be returned, if possible.  If</span>
<span class="sd">        &#39;always_create&#39; is False, the first existing alias that matches the</span>
<span class="sd">        &#39;connection&#39; is returned, if any. Otherwise a new join is created.</span>

<span class="sd">        If &#39;exclusions&#39; is specified, it is something satisfying the container</span>
<span class="sd">        protocol (&quot;foo in exclusions&quot; must work) and specifies a list of</span>
<span class="sd">        aliases that should not be returned, even if they satisfy the join.</span>

<span class="sd">        If &#39;promote&#39; is True, the join type for the alias will be LOUTER (if</span>
<span class="sd">        the alias previously existed, the join type will be promoted from INNER</span>
<span class="sd">        to LOUTER, if necessary).</span>

<span class="sd">        If &#39;outer_if_first&#39; is True and a new join is created, it will have the</span>
<span class="sd">        LOUTER join type. This is used when joining certain types of querysets</span>
<span class="sd">        and Q-objects together.</span>

<span class="sd">        If &#39;nullable&#39; is True, the join can potentially involve NULL values and</span>
<span class="sd">        is a candidate for promotion (to &quot;left outer&quot;) when combining querysets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lhs</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">lhs_col</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">connection</span>
        <span class="k">if</span> <span class="n">lhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">:</span>
            <span class="n">lhs_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="o">.</span><span class="n">table_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lhs_table</span> <span class="o">=</span> <span class="n">lhs</span>

        <span class="k">if</span> <span class="n">reuse</span> <span class="ow">and</span> <span class="n">always_create</span> <span class="ow">and</span> <span class="n">table</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_map</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-51"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-51">&#182;</a></div><p>Convert the 'reuse' to case to be "exclude everything but the
reusable set, minus exclusions, for this table".</p></td><td class="code"><div class="highlight"><pre>            <span class="n">exclusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">table_map</span><span class="p">[</span><span class="n">table</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">reuse</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">exclusions</span><span class="p">))</span>
            <span class="n">always_create</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">t_ident</span> <span class="o">=</span> <span class="p">(</span><span class="n">lhs_table</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">lhs_col</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">always_create</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t_ident</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">if</span> <span class="n">alias</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclusions</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">lhs_table</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span><span class="o">.</span><span class="n">lhs_alias</span><span class="p">]:</span></pre></div></td></tr>


<tr id="section-52"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-52">&#182;</a></div><p>The LHS of this join tuple is no longer part of the
query, so skip this possibility.</p></td><td class="code"><div class="highlight"><pre>                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span><span class="o">.</span><span class="n">lhs_alias</span> <span class="o">!=</span> <span class="n">lhs</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ref_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">promote</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">alias</span></pre></div></td></tr>


<tr id="section-53"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-53">&#182;</a></div><p>No reuse is possible, so we need a new alias.</p></td><td class="code"><div class="highlight"><pre>        <span class="n">alias</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_alias</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lhs</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-54"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-54">&#182;</a></div><p>Not all tables need to be joined to anything. No join type
means the later columns are ignored.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">join_type</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">promote</span> <span class="ow">or</span> <span class="n">outer_if_first</span><span class="p">:</span>
            <span class="n">join_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOUTER</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">join_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INNER</span>
        <span class="n">join</span> <span class="o">=</span> <span class="n">JoinInfo</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">join_type</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_col</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">nullable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span> <span class="o">=</span> <span class="n">join</span>
        <span class="k">if</span> <span class="n">t_ident</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">join_map</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">join_map</span><span class="p">[</span><span class="n">t_ident</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">alias</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">join_map</span><span class="p">[</span><span class="n">t_ident</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">alias</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">alias</span>

    <span class="k">def</span> <span class="nf">setup_inherited_models</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the model that is the basis for this QuerySet inherits other models,</span>
<span class="sd">        we need to ensure that those other models have their tables included in</span>
<span class="sd">        the query.</span>

<span class="sd">        We do this as a separate step so that subclasses know which</span>
<span class="sd">        tables are going to be active in the query, without needing to compute</span>
<span class="sd">        all the select columns (this method is called from pre_sql_setup(),</span>
<span class="sd">        whereas column determination is a later part, and side-effect, of</span>
<span class="sd">        as_sql()).</span>
<span class="sd">        &quot;&quot;&quot;</span></pre></div></td></tr>


<tr id="section-55"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-55">&#182;</a></div><p>Skip all proxy models</p></td><td class="code"><div class="highlight"><pre>        <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">concrete_model</span><span class="o">.</span><span class="n">_meta</span>
        <span class="n">root_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="n">root_alias</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_fields_with_model</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="n">link_field</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_ancestor_link</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
                <span class="n">seen</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">root_alias</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">db_table</span><span class="p">,</span>
                        <span class="n">link_field</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">pk</span><span class="o">.</span><span class="n">column</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">included_inherited_models</span> <span class="o">=</span> <span class="n">seen</span>

    <span class="k">def</span> <span class="nf">remove_inherited_models</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Undoes the effects of setup_inherited_models(). Should be called</span>
<span class="sd">        whenever select columns (self.select) are set explicitly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">alias</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">included_inherited_models</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unref_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">included_inherited_models</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">need_force_having</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether or not all elements of this q_object need to be put</span>
<span class="sd">        together in the HAVING clause.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">q_object</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">need_force_having</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
                    <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">LOOKUP_SEP</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">add_aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aggregate</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">is_summary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a single aggregate expression to the Query</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_meta</span>
        <span class="n">field_list</span> <span class="o">=</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">lookup</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">LOOKUP_SEP</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">aggregate</span><span class="o">.</span><span class="n">lookup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-56"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-56">&#182;</a></div><p>Aggregate is over an annotation</p></td><td class="code"><div class="highlight"><pre>            <span class="n">field_name</span> <span class="o">=</span> <span class="n">field_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">field_name</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_summary</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FieldError</span><span class="p">(</span><span class="s">&quot;Cannot compute </span><span class="si">%s</span><span class="s">(&#39;</span><span class="si">%s</span><span class="s">&#39;): &#39;</span><span class="si">%s</span><span class="s">&#39; is an aggregate&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">aggregate</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_name</span><span class="p">))</span>
        <span class="k">elif</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">field_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">field_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">fields</span><span class="p">])</span> <span class="ow">or</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span>
            <span class="ow">not</span> <span class="n">is_summary</span><span class="p">):</span></pre></div></td></tr>


<tr id="section-57"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-57">&#182;</a></div><p>If:
  - the field descriptor has more than one part (foo__bar), or
  - the field descriptor is referencing an m2m/m2o field, or
  - this is a reference to a model field (possibly inherited), or
  - this is an annotation over a model field
then we need to explore the joins that are required.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">field</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">join_list</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_joins</span><span class="p">(</span>
                <span class="n">field_list</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_alias</span><span class="p">(),</span> <span class="bp">False</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-58"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-58">&#182;</a></div><p>Process the join chain to see if it can be trimmed</p></td><td class="code"><div class="highlight"><pre>            <span class="n">col</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">join_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_joins</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">join_list</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-59"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-59">&#182;</a></div><p>If the aggregate references a model or field that requires a join,
those joins must be LEFT OUTER - empty join rows must be returned
in order for zeros to be returned for those aggregates.</p></td><td class="code"><div class="highlight"><pre>            <span class="k">for</span> <span class="n">column_alias</span> <span class="ow">in</span> <span class="n">join_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias</span><span class="p">(</span><span class="n">column_alias</span><span class="p">,</span> <span class="n">unconditional</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">join_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-60"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-60">&#182;</a></div><p>The simplest cases. No joins required -
just reference the provided column alias.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">field_name</span> <span class="o">=</span> <span class="n">field_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">field_name</span></pre></div></td></tr>


<tr id="section-61"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-61">&#182;</a></div><p>Add the aggregate to the query</p></td><td class="code"><div class="highlight"><pre>        <span class="n">aggregate</span><span class="o">.</span><span class="n">add_to_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">is_summary</span><span class="o">=</span><span class="n">is_summary</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_expr</span><span class="p">,</span> <span class="n">connector</span><span class="o">=</span><span class="n">AND</span><span class="p">,</span> <span class="n">negate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">can_reuse</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">process_extras</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">force_having</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a single filter to the query. The &#39;filter_expr&#39; is a pair:</span>
<span class="sd">        (filter_string, value). E.g. (&#39;name__contains&#39;, &#39;fred&#39;)</span>

<span class="sd">        If &#39;negate&#39; is True, this is an exclude() filter. It&#39;s important to</span>
<span class="sd">        note that this method does not negate anything in the where-clause</span>
<span class="sd">        object when inserting the filter constraints. This is because negated</span>
<span class="sd">        filters often require multiple calls to add_filter() and the negation</span>
<span class="sd">        should only happen once. So the caller is responsible for this (the</span>
<span class="sd">        caller will normally be add_q(), so that as an example).</span>

<span class="sd">        If &#39;trim&#39; is True, we automatically trim the final join group (used</span>
<span class="sd">        internally when constructing nested queries).</span>

<span class="sd">        If &#39;can_reuse&#39; is a set, we are processing a component of a</span>
<span class="sd">        multi-component filter (e.g. filter(Q1, Q2)). In this case, &#39;can_reuse&#39;</span>
<span class="sd">        will be a set of table aliases that can be reused in this filter, even</span>
<span class="sd">        if we would otherwise force the creation of new aliases for a join</span>
<span class="sd">        (needed for nested Q-filters). The set is updated by this method.</span>

<span class="sd">        If &#39;process_extras&#39; is set, any extra filters returned from the table</span>
<span class="sd">        joining process will be processed. This parameter is set to False</span>
<span class="sd">        during the processing of extra filters to avoid infinite recursion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arg</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">filter_expr</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">LOOKUP_SEP</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parts</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FieldError</span><span class="p">(</span><span class="s">&quot;Cannot parse keyword query </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">arg</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-62"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-62">&#182;</a></div><p>Work out the lookup type and remove it from the end of 'parts',
if necessary.</p></td><td class="code"><div class="highlight"><pre>        <span class="n">lookup_type</span> <span class="o">=</span> <span class="s">&#39;exact&#39;</span> <span class="c"># Default lookup type</span>
        <span class="n">num_parts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_terms</span>
            <span class="ow">and</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span><span class="p">):</span></pre></div></td></tr>


<tr id="section-63"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-63">&#182;</a></div><p>Traverse the lookup query to distinguish related fields from
lookup types.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">lookup_model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>
            <span class="k">for</span> <span class="n">counter</span><span class="p">,</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lookup_field</span> <span class="o">=</span> <span class="n">lookup_model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">get_field</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">FieldDoesNotExist</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-64"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-64">&#182;</a></div><p>Not a field. Bail out.</p></td><td class="code"><div class="highlight"><pre>                    <span class="n">lookup_type</span> <span class="o">=</span> <span class="n">parts</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">break</span></pre></div></td></tr>


<tr id="section-65"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-65">&#182;</a></div><p>Unless we're at the end of the list of lookups, let's attempt
to continue traversing relations.</p></td><td class="code"><div class="highlight"><pre>                <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_parts</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">lookup_model</span> <span class="o">=</span> <span class="n">lookup_field</span><span class="o">.</span><span class="n">rel</span><span class="o">.</span><span class="n">to</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-66"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-66">&#182;</a></div><p>Not a related field. Bail out.</p></td><td class="code"><div class="highlight"><pre>                        <span class="n">lookup_type</span> <span class="o">=</span> <span class="n">parts</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">break</span></pre></div></td></tr>


<tr id="section-67"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-67">&#182;</a></div><p>By default, this is a WHERE clause. If an aggregate is referenced
in the value, the filter will be promoted to a HAVING</p></td><td class="code"><div class="highlight"><pre>        <span class="n">having_clause</span> <span class="o">=</span> <span class="bp">False</span></pre></div></td></tr>


<tr id="section-68"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-68">&#182;</a></div><p>Interpret '__exact=None' as the sql 'is NULL'; otherwise, reject all
uses of None as a query value.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lookup_type</span> <span class="o">!=</span> <span class="s">&#39;exact&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Cannot use None as a query value&quot;</span><span class="p">)</span>
            <span class="n">lookup_type</span> <span class="o">=</span> <span class="s">&#39;isnull&#39;</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ExpressionNode</span><span class="p">):</span></pre></div></td></tr>


<tr id="section-69"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-69">&#182;</a></div><p>If value is a query expression, evaluate it</p></td><td class="code"><div class="highlight"><pre>            <span class="n">value</span> <span class="o">=</span> <span class="n">SQLEvaluator</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">having_clause</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">contains_aggregate</span>

        <span class="k">for</span> <span class="n">alias</span><span class="p">,</span> <span class="n">aggregate</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">alias</span> <span class="ow">in</span> <span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">LOOKUP_SEP</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)):</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where_class</span><span class="p">()</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">aggregate</span><span class="p">,</span> <span class="n">lookup_type</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">AND</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">negate</span><span class="p">:</span>
                    <span class="n">entry</span><span class="o">.</span><span class="n">negate</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">having</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">connector</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span>
        <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_alias</span><span class="p">()</span>
        <span class="n">allow_many</span> <span class="o">=</span> <span class="n">trim</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">negate</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">field</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">join_list</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">extra_filters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_joins</span><span class="p">(</span>
                    <span class="n">parts</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">allow_many</span><span class="p">,</span> <span class="n">allow_explicit_fk</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">can_reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">,</span> <span class="n">negate</span><span class="o">=</span><span class="n">negate</span><span class="p">,</span>
                    <span class="n">process_extras</span><span class="o">=</span><span class="n">process_extras</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">MultiJoin</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_exclude</span><span class="p">(</span><span class="n">filter_expr</span><span class="p">,</span> <span class="n">LOOKUP_SEP</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="n">e</span><span class="o">.</span><span class="n">level</span><span class="p">]),</span>
                    <span class="n">can_reuse</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">table_promote</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">join_promote</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">lookup_type</span> <span class="o">==</span> <span class="s">&#39;isnull&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">True</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">negate</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">join_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span></pre></div></td></tr>


<tr id="section-70"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-70">&#182;</a></div><p>If the comparison is against NULL, we may need to use some left
outer joins when creating the join chain. This is only done when
needed, as it's less efficient at the database level.</p></td><td class="code"><div class="highlight"><pre>            <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias_chain</span><span class="p">(</span><span class="n">join_list</span><span class="p">)</span>
            <span class="n">join_promote</span> <span class="o">=</span> <span class="bp">True</span></pre></div></td></tr>


<tr id="section-71"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-71">&#182;</a></div><p>Process the join list to see if we can remove any inner joins from
the far end (fewer tables in a query is better).</p></td><td class="code"><div class="highlight"><pre>        <span class="n">nonnull_comparison</span> <span class="o">=</span> <span class="p">(</span><span class="n">lookup_type</span> <span class="o">==</span> <span class="s">&#39;isnull&#39;</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">col</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">join_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_joins</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">join_list</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">trim</span><span class="p">,</span>
                <span class="n">nonnull_comparison</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">connector</span> <span class="o">==</span> <span class="n">OR</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-72"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-72">&#182;</a></div><p>Some joins may need to be promoted when adding a new filter to a
disjunction. We walk the list of new joins and where it diverges
from any previous joins (ref count is 1 in the table list), we
make the new additions (and any existing ones not used in the new
join list) an outer join.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">join_it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">join_list</span><span class="p">)</span>
            <span class="n">table_it</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">)</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">join_it</span><span class="p">),</span> <span class="nb">next</span><span class="p">(</span><span class="n">table_it</span><span class="p">)</span>
            <span class="n">unconditional</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">join</span> <span class="ow">in</span> <span class="n">join_it</span><span class="p">:</span>
                <span class="n">table</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">table_it</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-73"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-73">&#182;</a></div><p>Once we hit an outer join, all subsequent joins must
also be promoted, regardless of whether they have been
promoted as a result of this pass through the tables.</p></td><td class="code"><div class="highlight"><pre>                <span class="n">unconditional</span> <span class="o">=</span> <span class="p">(</span><span class="n">unconditional</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">join</span><span class="p">]</span><span class="o">.</span><span class="n">join_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOUTER</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">join</span> <span class="o">==</span> <span class="n">table</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="p">[</span><span class="n">join</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-74"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-74">&#182;</a></div><p>We have more than one reference to this join table.
This means that we are dealing with two different query
subtrees, so we don't need to do any join promotion.</p></td><td class="code"><div class="highlight"><pre>                    <span class="k">continue</span>
                <span class="n">join_promote</span> <span class="o">=</span> <span class="n">join_promote</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias</span><span class="p">(</span><span class="n">join</span><span class="p">,</span> <span class="n">unconditional</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">table</span> <span class="o">!=</span> <span class="n">join</span><span class="p">:</span>
                    <span class="n">table_promote</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias</span><span class="p">(</span><span class="n">table</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-75"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-75">&#182;</a></div><p>We only get here if we have found a table that exists
in the join list, but isn't on the original tables list.
This means we've reached the point where we only have
new tables, so we can break out of this promotion loop.</p></td><td class="code"><div class="highlight"><pre>                <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias_chain</span><span class="p">(</span><span class="n">join_it</span><span class="p">,</span> <span class="n">join_promote</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias_chain</span><span class="p">(</span><span class="n">table_it</span><span class="p">,</span> <span class="n">table_promote</span> <span class="ow">or</span> <span class="n">join_promote</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">having_clause</span> <span class="ow">or</span> <span class="n">force_having</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">alias</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">having</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">Constraint</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">field</span><span class="p">),</span> <span class="n">lookup_type</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span>
                <span class="n">connector</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">Constraint</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">field</span><span class="p">),</span> <span class="n">lookup_type</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span>
                <span class="n">connector</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">negate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias_chain</span><span class="p">(</span><span class="n">join_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lookup_type</span> <span class="o">!=</span> <span class="s">&#39;isnull&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">join_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">join_list</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span><span class="o">.</span><span class="n">join_type</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOUTER</span><span class="p">:</span>
                            <span class="n">j_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span><span class="o">.</span><span class="n">rhs_join_col</span>
                            <span class="n">entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">where_class</span><span class="p">()</span>
                            <span class="n">entry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">Constraint</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">j_col</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="s">&#39;isnull&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span>
                                <span class="n">AND</span>
                            <span class="p">)</span>
                            <span class="n">entry</span><span class="o">.</span><span class="n">negate</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">AND</span><span class="p">)</span>
                            <span class="k">break</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nullable</span><span class="p">(</span><span class="n">field</span><span class="p">):</span></pre></div></td></tr>


<tr id="section-76"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-76">&#182;</a></div><p>In SQL NULL = anyvalue returns unknown, and NOT unknown
is still unknown. However, in Python None = anyvalue is False
(and not False is True...), and we want to return this Python's
view of None handling. So we need to specifically exclude the
NULL values, and because we are inside NOT branch they will
be included in the final resultset. We are essentially creating
SQL like this here: NOT (col IS NOT NULL), where the first NOT
is added in upper layers of the code.</p></td><td class="code"><div class="highlight"><pre>                    <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">Constraint</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="s">&#39;isnull&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span> <span class="n">AND</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">can_reuse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">can_reuse</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">join_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">process_extras</span><span class="p">:</span>
            <span class="k">for</span> <span class="nb">filter</span> <span class="ow">in</span> <span class="n">extra_filters</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">(</span><span class="nb">filter</span><span class="p">,</span> <span class="n">negate</span><span class="o">=</span><span class="n">negate</span><span class="p">,</span> <span class="n">can_reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">,</span>
                        <span class="n">process_extras</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q_object</span><span class="p">,</span> <span class="n">used_aliases</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">force_having</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a Q-object to the current filter.</span>

<span class="sd">        Can also be used to add anything that has an &#39;add_to_query()&#39; method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">used_aliases</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">used_aliases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">used_aliases</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">q_object</span><span class="p">,</span> <span class="s">&#39;add_to_query&#39;</span><span class="p">):</span></pre></div></td></tr>


<tr id="section-77"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-77">&#182;</a></div><p>Complex custom objects are responsible for adding themselves.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">q_object</span><span class="o">.</span><span class="n">add_to_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">used_aliases</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span> <span class="ow">and</span> <span class="n">q_object</span><span class="o">.</span><span class="n">connector</span> <span class="o">!=</span> <span class="n">AND</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">q_object</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">start_subtree</span><span class="p">(</span><span class="n">AND</span><span class="p">)</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subtree</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">connector</span> <span class="o">=</span> <span class="n">AND</span>
            <span class="k">if</span> <span class="n">q_object</span><span class="o">.</span><span class="n">connector</span> <span class="o">==</span> <span class="n">OR</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">force_having</span><span class="p">:</span>
                <span class="n">force_having</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">need_force_having</span><span class="p">(</span><span class="n">q_object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">q_object</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">connector</span> <span class="o">==</span> <span class="n">OR</span><span class="p">:</span>
                    <span class="n">refcounts_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_refcount</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">force_having</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">having</span><span class="o">.</span><span class="n">start_subtree</span><span class="p">(</span><span class="n">connector</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">start_subtree</span><span class="p">(</span><span class="n">connector</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Node</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_q</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">used_aliases</span><span class="p">,</span> <span class="n">force_having</span><span class="o">=</span><span class="n">force_having</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">connector</span><span class="p">,</span> <span class="n">q_object</span><span class="o">.</span><span class="n">negated</span><span class="p">,</span>
                            <span class="n">can_reuse</span><span class="o">=</span><span class="n">used_aliases</span><span class="p">,</span> <span class="n">force_having</span><span class="o">=</span><span class="n">force_having</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">force_having</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">having</span><span class="o">.</span><span class="n">end_subtree</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">end_subtree</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">connector</span> <span class="o">==</span> <span class="n">OR</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-78"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-78">&#182;</a></div><p>Aliases that were newly added or not used at all need to
be promoted to outer joins if they are nullable relations.
(they shouldn't turn the whole conditional into the empty
set just because they don't match anything).</p></td><td class="code"><div class="highlight"><pre>                    <span class="bp">self</span><span class="o">.</span><span class="n">promote_unused_aliases</span><span class="p">(</span><span class="n">refcounts_before</span><span class="p">,</span> <span class="n">used_aliases</span><span class="p">)</span>
                <span class="n">connector</span> <span class="o">=</span> <span class="n">q_object</span><span class="o">.</span><span class="n">connector</span>
            <span class="k">if</span> <span class="n">q_object</span><span class="o">.</span><span class="n">negated</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">negate</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">subtree</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">end_subtree</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_is_sticky</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">used_aliases</span> <span class="o">=</span> <span class="n">used_aliases</span>

    <span class="k">def</span> <span class="nf">setup_joins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">dupe_multis</span><span class="p">,</span> <span class="n">allow_many</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">allow_explicit_fk</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">can_reuse</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">negate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">process_extras</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the necessary table joins for the passage through the fields</span>
<span class="sd">        given in &#39;names&#39;. &#39;opts&#39; is the Options class for the current model</span>
<span class="sd">        (which gives the table we are joining to), &#39;alias&#39; is the alias for the</span>
<span class="sd">        table we are joining to. If dupe_multis is True, any many-to-many or</span>
<span class="sd">        many-to-one joins will always create a new alias (necessary for</span>
<span class="sd">        disjunctive filters). If can_reuse is not None, it&#39;s a list of aliases</span>
<span class="sd">        that can be reused in these joins (nothing else can be reused in this</span>
<span class="sd">        case). Finally, &#39;negate&#39; is used in the same sense as for add_filter()</span>
<span class="sd">        -- it indicates an exclude() filter, or something similar. It is only</span>
<span class="sd">        passed in here so that it can be passed to a field&#39;s extra_filter() for</span>
<span class="sd">        customized behavior.</span>

<span class="sd">        Returns the final field involved in the join, the target database</span>
<span class="sd">        column (used for any &#39;where&#39; constraint), the final &#39;opts&#39; value and the</span>
<span class="sd">        list of tables joined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">joins</span> <span class="o">=</span> <span class="p">[</span><span class="n">alias</span><span class="p">]</span>
        <span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dupe_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">exclusions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">extra_filters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">int_alias</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">int_alias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">exclusions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">int_alias</span><span class="p">)</span>
            <span class="n">exclusions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
            <span class="n">last</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">joins</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;pk&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pk</span><span class="o">.</span><span class="n">name</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">field</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">m2m</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">FieldDoesNotExist</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">allow_explicit_fk</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">attname</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-79"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-79">&#182;</a></div><p>XXX: A hack to allow foo_id to work in values() for
backwards compatibility purposes. If we dropped that
feature, this could be removed.</p></td><td class="code"><div class="highlight"><pre>                        <span class="n">field</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">direct</span><span class="p">,</span> <span class="n">m2m</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">names</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_all_field_names</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">raise</span> <span class="n">FieldError</span><span class="p">(</span><span class="s">&quot;Cannot resolve keyword </span><span class="si">%r</span><span class="s"> into field. &quot;</span>
                            <span class="s">&quot;Choices are: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">)))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_many</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m2m</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">direct</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">joins</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unref_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">MultiJoin</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">model</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-80"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-80">&#182;</a></div><p>The field lives on a base class of the current model.
Skip the chain of proxy to the concrete proxied model</p></td><td class="code"><div class="highlight"><pre>                <span class="n">proxied_model</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">concrete_model</span>

                <span class="k">for</span> <span class="n">int_model</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_base_chain</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">int_model</span> <span class="ow">is</span> <span class="n">proxied_model</span><span class="p">:</span>
                        <span class="n">opts</span> <span class="o">=</span> <span class="n">int_model</span><span class="o">.</span><span class="n">_meta</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lhs_col</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">int_model</span><span class="p">]</span><span class="o">.</span><span class="n">column</span>
                        <span class="n">dedupe</span> <span class="o">=</span> <span class="n">lhs_col</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">duplicate_targets</span>
                        <span class="k">if</span> <span class="n">dedupe</span><span class="p">:</span>
                            <span class="n">exclusions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dupe_avoidance</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                    <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">opts</span><span class="p">),</span> <span class="n">lhs_col</span><span class="p">),</span> <span class="p">()))</span>
                            <span class="n">dupe_set</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">opts</span><span class="p">,</span> <span class="n">lhs_col</span><span class="p">))</span>
                        <span class="n">opts</span> <span class="o">=</span> <span class="n">int_model</span><span class="o">.</span><span class="n">_meta</span>
                        <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">alias</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">db_table</span><span class="p">,</span> <span class="n">lhs_col</span><span class="p">,</span>
                                <span class="n">opts</span><span class="o">.</span><span class="n">pk</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="n">exclusions</span><span class="o">=</span><span class="n">exclusions</span><span class="p">)</span>
                        <span class="n">joins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                        <span class="n">exclusions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">dupe_opts</span><span class="p">,</span> <span class="n">dupe_col</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dupe_set</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">update_dupe_avoidance</span><span class="p">(</span><span class="n">dupe_opts</span><span class="p">,</span> <span class="n">dupe_col</span><span class="p">,</span>
                                    <span class="n">alias</span><span class="p">)</span>
            <span class="n">cached_data</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">_join_cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">orig_opts</span> <span class="o">=</span> <span class="n">opts</span>
            <span class="n">dupe_col</span> <span class="o">=</span> <span class="n">direct</span> <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">column</span> <span class="ow">or</span> <span class="n">field</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">column</span>
            <span class="n">dedupe</span> <span class="o">=</span> <span class="n">dupe_col</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">duplicate_targets</span>
            <span class="k">if</span> <span class="n">dupe_set</span> <span class="ow">or</span> <span class="n">dedupe</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dedupe</span><span class="p">:</span>
                    <span class="n">dupe_set</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">opts</span><span class="p">,</span> <span class="n">dupe_col</span><span class="p">))</span>
                <span class="n">exclusions</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dupe_avoidance</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="nb">id</span><span class="p">(</span><span class="n">opts</span><span class="p">),</span> <span class="n">dupe_col</span><span class="p">),</span>
                        <span class="p">()))</span>

            <span class="k">if</span> <span class="n">process_extras</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="s">&#39;extra_filters&#39;</span><span class="p">):</span>
                <span class="n">extra_filters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">extra_filters</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">negate</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">direct</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m2m</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-81"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-81">&#182;</a></div><p>Many-to-many field defined on the current model.</p></td><td class="code"><div class="highlight"><pre>                    <span class="k">if</span> <span class="n">cached_data</span><span class="p">:</span>
                        <span class="p">(</span><span class="n">table1</span><span class="p">,</span> <span class="n">from_col1</span><span class="p">,</span> <span class="n">to_col1</span><span class="p">,</span> <span class="n">table2</span><span class="p">,</span> <span class="n">from_col2</span><span class="p">,</span>
                                <span class="n">to_col2</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">=</span> <span class="n">cached_data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">table1</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">m2m_db_table</span><span class="p">()</span>
                        <span class="n">from_col1</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span>
                            <span class="n">field</span><span class="o">.</span><span class="n">m2m_target_field_name</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">column</span>
                        <span class="n">to_col1</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">m2m_column_name</span><span class="p">()</span>
                        <span class="n">opts</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">rel</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">_meta</span>
                        <span class="n">table2</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">db_table</span>
                        <span class="n">from_col2</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">m2m_reverse_name</span><span class="p">()</span>
                        <span class="n">to_col2</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span>
                            <span class="n">field</span><span class="o">.</span><span class="n">m2m_reverse_target_field_name</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">column</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pk</span>
                        <span class="n">orig_opts</span><span class="o">.</span><span class="n">_join_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">table1</span><span class="p">,</span> <span class="n">from_col1</span><span class="p">,</span>
                                <span class="n">to_col1</span><span class="p">,</span> <span class="n">table2</span><span class="p">,</span> <span class="n">from_col2</span><span class="p">,</span> <span class="n">to_col2</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span>
                                <span class="n">target</span><span class="p">)</span>

                    <span class="n">int_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">alias</span><span class="p">,</span> <span class="n">table1</span><span class="p">,</span> <span class="n">from_col1</span><span class="p">,</span> <span class="n">to_col1</span><span class="p">),</span>
                            <span class="n">dupe_multis</span><span class="p">,</span> <span class="n">exclusions</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                            <span class="n">reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">int_alias</span> <span class="o">==</span> <span class="n">table2</span> <span class="ow">and</span> <span class="n">from_col2</span> <span class="o">==</span> <span class="n">to_col2</span><span class="p">:</span>
                        <span class="n">joins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">int_alias</span><span class="p">)</span>
                        <span class="n">alias</span> <span class="o">=</span> <span class="n">int_alias</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">int_alias</span><span class="p">,</span> <span class="n">table2</span><span class="p">,</span> <span class="n">from_col2</span><span class="p">,</span> <span class="n">to_col2</span><span class="p">),</span>
                                <span class="n">dupe_multis</span><span class="p">,</span> <span class="n">exclusions</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                <span class="n">reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">)</span>
                        <span class="n">joins</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">int_alias</span><span class="p">,</span> <span class="n">alias</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">field</span><span class="o">.</span><span class="n">rel</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-82"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-82">&#182;</a></div><p>One-to-one or many-to-one field</p></td><td class="code"><div class="highlight"><pre>                    <span class="k">if</span> <span class="n">cached_data</span><span class="p">:</span>
                        <span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">from_col</span><span class="p">,</span> <span class="n">to_col</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">=</span> <span class="n">cached_data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">opts</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">rel</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">_meta</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">rel</span><span class="o">.</span><span class="n">get_related_field</span><span class="p">()</span>
                        <span class="n">table</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">db_table</span>
                        <span class="n">from_col</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">column</span>
                        <span class="n">to_col</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">column</span>
                        <span class="n">orig_opts</span><span class="o">.</span><span class="n">_join_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">from_col</span><span class="p">,</span> <span class="n">to_col</span><span class="p">,</span>
                                <span class="n">opts</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

                    <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">alias</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">from_col</span><span class="p">,</span> <span class="n">to_col</span><span class="p">),</span>
                                      <span class="n">exclusions</span><span class="o">=</span><span class="n">exclusions</span><span class="p">,</span>
                                      <span class="n">nullable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_nullable</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>
                    <span class="n">joins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-83"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-83">&#182;</a></div><p>Non-relation fields.</p></td><td class="code"><div class="highlight"><pre>                    <span class="n">target</span> <span class="o">=</span> <span class="n">field</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">orig_field</span> <span class="o">=</span> <span class="n">field</span>
                <span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">field</span>
                <span class="k">if</span> <span class="n">m2m</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-84"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-84">&#182;</a></div><p>Many-to-many field defined on the target model.</p></td><td class="code"><div class="highlight"><pre>                    <span class="k">if</span> <span class="n">cached_data</span><span class="p">:</span>
                        <span class="p">(</span><span class="n">table1</span><span class="p">,</span> <span class="n">from_col1</span><span class="p">,</span> <span class="n">to_col1</span><span class="p">,</span> <span class="n">table2</span><span class="p">,</span> <span class="n">from_col2</span><span class="p">,</span>
                                <span class="n">to_col2</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">=</span> <span class="n">cached_data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">table1</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">m2m_db_table</span><span class="p">()</span>
                        <span class="n">from_col1</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span>
                            <span class="n">field</span><span class="o">.</span><span class="n">m2m_reverse_target_field_name</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">column</span>
                        <span class="n">to_col1</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">m2m_reverse_name</span><span class="p">()</span>
                        <span class="n">opts</span> <span class="o">=</span> <span class="n">orig_field</span><span class="o">.</span><span class="n">opts</span>
                        <span class="n">table2</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">db_table</span>
                        <span class="n">from_col2</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">m2m_column_name</span><span class="p">()</span>
                        <span class="n">to_col2</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span>
                            <span class="n">field</span><span class="o">.</span><span class="n">m2m_target_field_name</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">column</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pk</span>
                        <span class="n">orig_opts</span><span class="o">.</span><span class="n">_join_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">table1</span><span class="p">,</span> <span class="n">from_col1</span><span class="p">,</span>
                                <span class="n">to_col1</span><span class="p">,</span> <span class="n">table2</span><span class="p">,</span> <span class="n">from_col2</span><span class="p">,</span> <span class="n">to_col2</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span>
                                <span class="n">target</span><span class="p">)</span>

                    <span class="n">int_alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">alias</span><span class="p">,</span> <span class="n">table1</span><span class="p">,</span> <span class="n">from_col1</span><span class="p">,</span> <span class="n">to_col1</span><span class="p">),</span>
                            <span class="n">dupe_multis</span><span class="p">,</span> <span class="n">exclusions</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                            <span class="n">reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">)</span>
                    <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">int_alias</span><span class="p">,</span> <span class="n">table2</span><span class="p">,</span> <span class="n">from_col2</span><span class="p">,</span> <span class="n">to_col2</span><span class="p">),</span>
                            <span class="n">dupe_multis</span><span class="p">,</span> <span class="n">exclusions</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                            <span class="n">reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">)</span>
                    <span class="n">joins</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">int_alias</span><span class="p">,</span> <span class="n">alias</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-85"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-85">&#182;</a></div><p>One-to-many field (ForeignKey defined on the target model)</p></td><td class="code"><div class="highlight"><pre>                    <span class="k">if</span> <span class="n">cached_data</span><span class="p">:</span>
                        <span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">from_col</span><span class="p">,</span> <span class="n">to_col</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">=</span> <span class="n">cached_data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">local_field</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span>
                                <span class="n">field</span><span class="o">.</span><span class="n">rel</span><span class="o">.</span><span class="n">field_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">opts</span> <span class="o">=</span> <span class="n">orig_field</span><span class="o">.</span><span class="n">opts</span>
                        <span class="n">table</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">db_table</span>
                        <span class="n">from_col</span> <span class="o">=</span> <span class="n">local_field</span><span class="o">.</span><span class="n">column</span>
                        <span class="n">to_col</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">column</span></pre></div></td></tr>


<tr id="section-86"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-86">&#182;</a></div><p>In case of a recursive FK, use the to_field for
reverse lookups as well</p></td><td class="code"><div class="highlight"><pre>                        <span class="k">if</span> <span class="n">orig_field</span><span class="o">.</span><span class="n">model</span> <span class="ow">is</span> <span class="n">local_field</span><span class="o">.</span><span class="n">model</span><span class="p">:</span>
                            <span class="n">target</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_field_by_name</span><span class="p">(</span>
                                <span class="n">field</span><span class="o">.</span><span class="n">rel</span><span class="o">.</span><span class="n">field_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">target</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pk</span>
                        <span class="n">orig_opts</span><span class="o">.</span><span class="n">_join_cache</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">from_col</span><span class="p">,</span> <span class="n">to_col</span><span class="p">,</span>
                                <span class="n">opts</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

                    <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">alias</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">from_col</span><span class="p">,</span> <span class="n">to_col</span><span class="p">),</span>
                            <span class="n">dupe_multis</span><span class="p">,</span> <span class="n">exclusions</span><span class="p">,</span> <span class="n">nullable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                            <span class="n">reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">)</span>
                    <span class="n">joins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">dupe_opts</span><span class="p">,</span> <span class="n">dupe_col</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dupe_set</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">int_alias</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">to_avoid</span> <span class="o">=</span> <span class="n">alias</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_avoid</span> <span class="o">=</span> <span class="n">int_alias</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_dupe_avoidance</span><span class="p">(</span><span class="n">dupe_opts</span><span class="p">,</span> <span class="n">dupe_col</span><span class="p">,</span> <span class="n">to_avoid</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FieldError</span><span class="p">(</span><span class="s">&quot;Join on field </span><span class="si">%r</span><span class="s"> not permitted. Did you misspell </span><span class="si">%r</span><span class="s"> for the lookup type?&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">FieldError</span><span class="p">(</span><span class="s">&quot;Join on field </span><span class="si">%r</span><span class="s"> not permitted.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">field</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">joins</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">extra_filters</span>

    <span class="k">def</span> <span class="nf">trim_joins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">join_list</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">trim</span><span class="p">,</span> <span class="n">nonnull_check</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sometimes joins at the end of a multi-table sequence can be trimmed. If</span>
<span class="sd">        the final join is against the same column as we are comparing against,</span>
<span class="sd">        and is an inner join, we can go back one step in a join chain and</span>
<span class="sd">        compare against the LHS of the join instead (and then repeat the</span>
<span class="sd">        optimization). The result, potentially, involves fewer table joins.</span>

<span class="sd">        The &#39;target&#39; parameter is the final field being joined to, &#39;join_list&#39;</span>
<span class="sd">        is the full list of join aliases.</span>

<span class="sd">        The &#39;last&#39; list contains offsets into &#39;join_list&#39;, corresponding to</span>
<span class="sd">        each component of the filter. Many-to-many relations, for example, add</span>
<span class="sd">        two tables to the join list and we want to deal with both tables the</span>
<span class="sd">        same way, so &#39;last&#39; has an entry for the first of the two tables and</span>
<span class="sd">        then the table immediately after the second table, in that case.</span>

<span class="sd">        The &#39;trim&#39; parameter forces the final piece of the join list to be</span>
<span class="sd">        trimmed before anything. See the documentation of add_filter() for</span>
<span class="sd">        details about this.</span>

<span class="sd">        The &#39;nonnull_check&#39; parameter is True when we are using inner joins</span>
<span class="sd">        between tables explicitly to exclude NULL entries. In that case, the</span>
<span class="sd">        tables shouldn&#39;t be trimmed, because the very action of joining to them</span>
<span class="sd">        alters the result set.</span>

<span class="sd">        Returns the final active column and table alias and the new active</span>
<span class="sd">        join_list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">final</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">join_list</span><span class="p">)</span>
        <span class="n">penultimate</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">penultimate</span> <span class="o">==</span> <span class="n">final</span><span class="p">:</span>
            <span class="n">penultimate</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">trim</span> <span class="ow">and</span> <span class="n">final</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">extra</span> <span class="o">=</span> <span class="n">join_list</span><span class="p">[</span><span class="n">penultimate</span><span class="p">:]</span>
            <span class="n">join_list</span> <span class="o">=</span> <span class="n">join_list</span><span class="p">[:</span><span class="n">penultimate</span><span class="p">]</span>
            <span class="n">final</span> <span class="o">=</span> <span class="n">penultimate</span>
            <span class="n">penultimate</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">extra</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">lhs_join_col</span>
            <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">extra</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unref_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">column</span>
        <span class="n">alias</span> <span class="o">=</span> <span class="n">join_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">final</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">join</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">col</span> <span class="o">!=</span> <span class="n">join</span><span class="o">.</span><span class="n">rhs_join_col</span> <span class="ow">or</span> <span class="n">join</span><span class="o">.</span><span class="n">join_type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INNER</span> <span class="ow">or</span>
                    <span class="n">nonnull_check</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unref_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="n">join</span><span class="o">.</span><span class="n">lhs_alias</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">join</span><span class="o">.</span><span class="n">lhs_join_col</span>
            <span class="n">join_list</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">final</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">final</span> <span class="o">==</span> <span class="n">penultimate</span><span class="p">:</span>
                <span class="n">penultimate</span> <span class="o">=</span> <span class="n">last</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">col</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">join_list</span>

    <span class="k">def</span> <span class="nf">update_dupe_avoidance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">alias</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For a column that is one of multiple pointing to the same table, update</span>
<span class="sd">        the internal data structures to note that this alias shouldn&#39;t be used</span>
<span class="sd">        for those other columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ident</span> <span class="o">=</span> <span class="nb">id</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">opts</span><span class="o">.</span><span class="n">duplicate_targets</span><span class="p">[</span><span class="n">col</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dupe_avoidance</span><span class="p">[</span><span class="n">ident</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dupe_avoidance</span><span class="p">[</span><span class="n">ident</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">alias</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">split_exclude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_expr</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">can_reuse</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When doing an exclude against any kind of N-to-many relation, we need</span>
<span class="sd">        to use a subquery. This method constructs the nested query, given the</span>
<span class="sd">        original exclude filter (filter_expr) and the portion up to the first</span>
<span class="sd">        N-to-many relation field.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">Query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">query</span><span class="o">.</span><span class="n">add_filter</span><span class="p">(</span><span class="n">filter_expr</span><span class="p">,</span> <span class="n">can_reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">)</span>
        <span class="n">query</span><span class="o">.</span><span class="n">bump_prefix</span><span class="p">()</span>
        <span class="n">query</span><span class="o">.</span><span class="n">clear_ordering</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">query</span><span class="o">.</span><span class="n">set_start</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-87"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-87">&#182;</a></div><p>Adding extra check to make sure the selected field will not be null
since we are adding a IN <subquery> clause. This prevents the
database from tripping over IN (...,NULL,...) selects and returning
nothing</p></td><td class="code"><div class="highlight"><pre>        <span class="n">alias</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">select</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">query</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">Constraint</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="s">&#39;isnull&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span> <span class="n">AND</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">((</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">__in&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">query</span><span class="p">),</span> <span class="n">negate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                <span class="n">can_reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-88"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-88">&#182;</a></div><p>If there's more than one join in the inner query (before any initial
bits were trimmed -- which means the last active table is more than
two places into the alias list), we need to also handle the
possibility that the earlier joins don't match anything by adding a
comparison to NULL (e.g. in
Tag.objects.exclude(parent<strong>parent</strong>name='t1'), a tag with no parent
would otherwise be overlooked).</p></td><td class="code"><div class="highlight"><pre>        <span class="n">active_positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span> <span class="k">for</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span> <span class="ow">in</span>
                <span class="nb">enumerate</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">alias_refcount</span><span class="o">.</span><span class="n">itervalues</span><span class="p">())</span> <span class="k">if</span> <span class="n">count</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">active_positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_filter</span><span class="p">((</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">__isnull&#39;</span> <span class="o">%</span> <span class="n">prefix</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span> <span class="n">negate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                    <span class="n">trim</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">can_reuse</span><span class="o">=</span><span class="n">can_reuse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjusts the limits on the rows retrieved. We use low/high to set these,</span>
<span class="sd">        as it makes it more Pythonic to read and write. When the SQL query is</span>
<span class="sd">        created, they are converted to the appropriate offset and limit values.</span>

<span class="sd">        Any limits passed in here are applied relative to the existing</span>
<span class="sd">        constraints. So low is added to the current low value and both will be</span>
<span class="sd">        clamped to any existing high value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span> <span class="o">+</span> <span class="n">high</span>
        <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span> <span class="o">+</span> <span class="n">low</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span> <span class="o">+</span> <span class="n">low</span>

    <span class="k">def</span> <span class="nf">clear_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears any existing limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">can_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if adding filters to this instance is still possible.</span>

<span class="sd">        Typically, this means no limits or offsets have been put on the results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">low_mark</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">high_mark</span> <span class="ow">is</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">clear_select_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears the list of fields to select (but not extra_select columns).</span>
<span class="sd">        Some queryset types completely replace any existing list of select</span>
<span class="sd">        columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_fields</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_distinct_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">field_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds and resolves the given fields to the query&#39;s &quot;distinct on&quot; clause.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distinct_fields</span> <span class="o">=</span> <span class="n">field_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distinct</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">add_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_names</span><span class="p">,</span> <span class="n">allow_m2m</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the given (model) fields to the select set. The field names are</span>
<span class="sd">        added in the order specified.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_alias</span><span class="p">()</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_meta</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">:</span>
                <span class="n">field</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">u2</span><span class="p">,</span> <span class="n">joins</span><span class="p">,</span> <span class="n">u3</span><span class="p">,</span> <span class="n">u4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_joins</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">LOOKUP_SEP</span><span class="p">),</span> <span class="n">opts</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="n">allow_m2m</span><span class="p">,</span>
                        <span class="bp">True</span><span class="p">)</span>
                <span class="n">final_alias</span> <span class="o">=</span> <span class="n">joins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">column</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">joins</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">join</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">final_alias</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="n">join</span><span class="o">.</span><span class="n">rhs_join_col</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">unref_alias</span><span class="p">(</span><span class="n">final_alias</span><span class="p">)</span>
                        <span class="n">final_alias</span> <span class="o">=</span> <span class="n">join</span><span class="o">.</span><span class="n">lhs_alias</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="n">join</span><span class="o">.</span><span class="n">lhs_join_col</span>
                        <span class="n">joins</span> <span class="o">=</span> <span class="n">joins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">promote_alias_chain</span><span class="p">(</span><span class="n">joins</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">final_alias</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">select_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">MultiJoin</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FieldError</span><span class="p">(</span><span class="s">&quot;Invalid field name: &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">FieldError</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">get_all_field_names</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">names</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">raise</span> <span class="n">FieldError</span><span class="p">(</span><span class="s">&quot;Cannot resolve keyword </span><span class="si">%r</span><span class="s"> into field. &quot;</span>
                    <span class="s">&quot;Choices are: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_inherited_models</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_ordering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ordering</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds items from the &#39;ordering&#39; sequence to the query&#39;s &quot;order by&quot;</span>
<span class="sd">        clause. These items are either field names (not column names) --</span>
<span class="sd">        possibly with a direction prefix (&#39;-&#39; or &#39;?&#39;) -- or ordinals,</span>
<span class="sd">        corresponding to column positions in the &#39;select&#39; list.</span>

<span class="sd">        If &#39;ordering&#39; is empty, all ordering is cleared from the query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">ordering</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ORDER_PATTERN</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FieldError</span><span class="p">(</span><span class="s">&#39;Invalid order_by arguments: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">errors</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ordering</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ordering</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_ordering</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">clear_ordering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_empty</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes any ordering settings. If &#39;force_empty&#39; is True, there will be</span>
<span class="sd">        no ordering in the resulting query (not even the model&#39;s default).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extra_order_by</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">if</span> <span class="n">force_empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">default_ordering</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">set_group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expands the GROUP BY clause required by the query.</span>

<span class="sd">        This will usually be the set of all non-aggregate fields in the</span>
<span class="sd">        return data. If the database backend supports grouping by the</span>
<span class="sd">        primary key, and the query would be equivalent, the optimization</span>
<span class="sd">        will be made automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">sel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_count_column</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the query to do count(...) or count(distinct(pk)) in order to</span>
<span class="sd">        get its size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">distinct</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates_module</span><span class="o">.</span><span class="n">Count</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">,</span> <span class="n">is_summary</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> \
                        <span class="s">&quot;Cannot add count col with multiple cols in &#39;select&#39;: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span>
                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates_module</span><span class="o">.</span><span class="n">Count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_meta</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates_module</span><span class="o">.</span><span class="n">Count</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="bp">None</span><span class="p">,</span> <span class="n">opts</span><span class="o">.</span><span class="n">db_table</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)),</span> <span class="n">opts</span><span class="o">.</span><span class="n">pk</span><span class="o">.</span><span class="n">column</span><span class="p">),</span>
                                         <span class="n">is_summary</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-89"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-89">&#182;</a></div><p>Because of SQL portability issues, multi-column, distinct
counts need a sub-query -- see get_count() for details.</p></td><td class="code"><div class="highlight"><pre>                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> \
                        <span class="s">&quot;Cannot add count col with multiple cols in &#39;select&#39;.&quot;</span>

                <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates_module</span><span class="o">.</span><span class="n">Count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">distinct</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-90"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-90">&#182;</a></div><p>Distinct handling is done in Count(), so don't do it at this
level.</p></td><td class="code"><div class="highlight"><pre>            <span class="bp">self</span><span class="o">.</span><span class="n">distinct</span> <span class="o">=</span> <span class="bp">False</span></pre></div></td></tr>


<tr id="section-91"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-91">&#182;</a></div><p>Set only aggregate to be the count column.
Clear out the select cache to reflect the new unmasked aggregates.</p></td><td class="code"><div class="highlight"><pre>        <span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span> <span class="o">=</span> <span class="p">{</span><span class="bp">None</span><span class="p">:</span> <span class="n">count</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aggregate_mask</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_by</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">add_select_related</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up the select_related data structure so that we only select</span>
<span class="sd">        certain related models (as opposed to all models, when</span>
<span class="sd">        self.select_related=True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">field_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">field_dict</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">LOOKUP_SEP</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_related</span> <span class="o">=</span> <span class="n">field_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">related_select_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">related_select_fields</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">add_extra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">select</span><span class="p">,</span> <span class="n">select_params</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">tables</span><span class="p">,</span> <span class="n">order_by</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds data to the various extra_* attributes for user-created additions</span>
<span class="sd">        to the query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">select</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-92"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-92">&#182;</a></div><p>We need to pair any placeholder markers in the 'select'
dictionary with their parameters in 'select_params' so that
subsequent updates to the select dictionary also adjust the
parameters appropriately.</p></td><td class="code"><div class="highlight"><pre>            <span class="n">select_pairs</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">select_params</span><span class="p">:</span>
                <span class="n">param_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">select_params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">param_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">select</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">entry</span> <span class="o">=</span> <span class="n">force_unicode</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
                <span class="n">entry_params</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">pos</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">entry_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">param_iter</span><span class="p">))</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">select_pairs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">entry_params</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-93"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-93">&#182;</a></div><p>This is order preserving, since self.extra_select is a SortedDict.</p></td><td class="code"><div class="highlight"><pre>            <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">select_pairs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">where</span> <span class="ow">or</span> <span class="n">params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ExtraWhere</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">params</span><span class="p">),</span> <span class="n">AND</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tables</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extra_tables</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tables</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order_by</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extra_order_by</span> <span class="o">=</span> <span class="n">order_by</span>

    <span class="k">def</span> <span class="nf">clear_deferred_loading</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove any fields from the deferred loading set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(),</span> <span class="bp">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_deferred_loading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the given list of model field names to the set of fields to</span>
<span class="sd">        exclude from loading from the database when automatic column selection</span>
<span class="sd">        is done. The new field names are added to any existing field names that</span>
<span class="sd">        are deferred (or removed from any existing field names that are marked</span>
<span class="sd">        as the only ones for immediate loading).</span>
<span class="sd">        &quot;&quot;&quot;</span></pre></div></td></tr>


<tr id="section-94"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-94">&#182;</a></div><p>Fields on related models are stored in the literal double-underscore
format, so that we can use a set datastructure. We do the foo<em>_bar
splitting and handling when computing the SQL colum names (as part of
get</em>columns()).</p></td><td class="code"><div class="highlight"><pre>        <span class="n">existing</span><span class="p">,</span> <span class="n">defer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span>
        <span class="k">if</span> <span class="n">defer</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-95"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-95">&#182;</a></div><p>Add to existing deferred names.</p></td><td class="code"><div class="highlight"><pre>            <span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">field_names</span><span class="p">),</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-96"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-96">&#182;</a></div><p>Remove names from the set of any existing "immediate load" names.</p></td><td class="code"><div class="highlight"><pre>            <span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">field_names</span><span class="p">),</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">add_immediate_loading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the given list of model field names to the set of fields to</span>
<span class="sd">        retrieve when the SQL is executed (&quot;immediate loading&quot; fields). The</span>
<span class="sd">        field names replace any existing immediate loading field names. If</span>
<span class="sd">        there are field names already specified for deferred loading, those</span>
<span class="sd">        names are removed from the new field_names before storing the new names</span>
<span class="sd">        for immediate loading. (That is, immediate loading overrides any</span>
<span class="sd">        existing immediate values, but respects existing deferrals.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">existing</span><span class="p">,</span> <span class="n">defer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span>
        <span class="n">field_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">field_names</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;pk&#39;</span> <span class="ow">in</span> <span class="n">field_names</span><span class="p">:</span>
            <span class="n">field_names</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s">&#39;pk&#39;</span><span class="p">)</span>
            <span class="n">field_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">pk</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">defer</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-97"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-97">&#182;</a></div><p>Remove any existing deferred names from the current set before
setting the new names.</p></td><td class="code"><div class="highlight"><pre>            <span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span> <span class="o">=</span> <span class="n">field_names</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">existing</span><span class="p">),</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span></pre></div></td></tr>


<tr id="section-98"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-98">&#182;</a></div><p>Replace any existing "immediate load" field names.</p></td><td class="code"><div class="highlight"><pre>            <span class="bp">self</span><span class="o">.</span><span class="n">deferred_loading</span> <span class="o">=</span> <span class="n">field_names</span><span class="p">,</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">get_loaded_field_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If any fields are marked to be deferred, returns a dictionary mapping</span>
<span class="sd">        models to a set of names in those fields that will be loaded. If a</span>
<span class="sd">        model is not in the returned dictionary, none of it&#39;s fields are</span>
<span class="sd">        deferred.</span>

<span class="sd">        If no fields are marked for deferral, returns an empty dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span></pre></div></td></tr>


<tr id="section-99"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-99">&#182;</a></div><p>We cache this because we call this function multiple times
(compiler.fill<em>related</em>selections, query.iterator)</p></td><td class="code"><div class="highlight"><pre>        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loaded_field_names_cache</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deferred_to_data</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loaded_field_names_cb</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loaded_field_names_cache</span> <span class="o">=</span> <span class="n">collection</span>
            <span class="k">return</span> <span class="n">collection</span>

    <span class="k">def</span> <span class="nf">get_loaded_field_names_cb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback used by get_deferred_field_names().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target</span><span class="p">[</span><span class="n">model</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">set_aggregate_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="s">&quot;Set the mask of aggregates that will actually be returned by the SELECT&quot;</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select_mask</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select_mask</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_select_cache</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">set_extra_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the mask of extra select items that will be returned by SELECT,</span>
<span class="sd">        we don&#39;t actually remove them from the Query since they might be used</span>
<span class="sd">        later</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extra_select_mask</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extra_select_mask</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extra_select_cache</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_aggregate_select</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The SortedDict of aggregate columns that are not masked, and should</span>
<span class="sd">        be used in the SELECT clause.</span>

<span class="sd">        This result is cached for optimization purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_select_cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_select_cache</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_select_cache</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">([</span>
                <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_select_mask</span>
            <span class="p">])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_select_cache</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregates</span>
    <span class="n">aggregate_select</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_aggregate_select</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extra_select</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_select_cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_select_cache</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_select_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extra_select_cache</span> <span class="o">=</span> <span class="n">SortedDict</span><span class="p">([</span>
                <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra_select_mask</span>
            <span class="p">])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extra_select_cache</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extra</span>
    <span class="n">extra_select</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_extra_select</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the table from which to start joining. The start position is</span>
<span class="sd">        specified by the related attribute from the base model. This will</span>
<span class="sd">        automatically set to the select column to be the column linked from the</span>
<span class="sd">        previous table.</span>

<span class="sd">        This method is primarily for internal use and the error checking isn&#39;t</span>
<span class="sd">        as friendly as add_filter(). Mostly useful for querying directly</span>
<span class="sd">        against the join table of many-to-many relation in a subquery.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">_meta</span>
        <span class="n">alias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_alias</span><span class="p">()</span>
        <span class="n">field</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">joins</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_joins</span><span class="p">(</span>
                <span class="n">start</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">LOOKUP_SEP</span><span class="p">),</span> <span class="n">opts</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">select_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">joins</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">lhs_join_col</span>
        <span class="n">select_alias</span> <span class="o">=</span> <span class="n">alias</span></pre></div></td></tr>


<tr id="section-100"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-100">&#182;</a></div><p>The call to setup_joins added an extra reference to everything in
joins. Reverse that.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">joins</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unref_alias</span><span class="p">(</span><span class="n">alias</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-101"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-101">&#182;</a></div><p>We might be able to trim some joins from the front of this query,
providing that we only traverse "always equal" connections (i.e. rhs
is <em>always</em> the same value as lhs).</p></td><td class="code"><div class="highlight"><pre>        <span class="k">for</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">joins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">join_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alias_map</span><span class="p">[</span><span class="n">alias</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">join_info</span><span class="o">.</span><span class="n">lhs_join_col</span> <span class="o">!=</span> <span class="n">select_col</span>
                    <span class="ow">or</span> <span class="n">join_info</span><span class="o">.</span><span class="n">join_type</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INNER</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unref_alias</span><span class="p">(</span><span class="n">select_alias</span><span class="p">)</span>
            <span class="n">select_alias</span> <span class="o">=</span> <span class="n">join_info</span><span class="o">.</span><span class="n">rhs_alias</span>
            <span class="n">select_col</span> <span class="o">=</span> <span class="n">join_info</span><span class="o">.</span><span class="n">rhs_join_col</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="p">[(</span><span class="n">select_alias</span><span class="p">,</span> <span class="n">select_col</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_inherited_models</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_nullable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A helper to check if the given field should be treated as nullable.</span>

<span class="sd">        Some backends treat &#39;&#39; as null and Django treats such fields as</span>
<span class="sd">        nullable for those backends. In such situations field.null can be</span>
<span class="sd">        False even if we should treat the field as nullable.</span>
<span class="sd">        &quot;&quot;&quot;</span></pre></div></td></tr>


<tr id="section-102"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-102">&#182;</a></div><p>We need to use DEFAULT<em>DB</em>ALIAS here, as QuerySet does not have
(nor should it have) knowledge of which connection is going to be
used. The proper fix would be to defer all decisions where
is_nullable() is needed to the compiler stage, but that is not easy
to do currently.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="p">((</span><span class="n">connections</span><span class="p">[</span><span class="n">DEFAULT_DB_ALIAS</span><span class="p">]</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">interprets_empty_strings_as_nulls</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">empty_strings_allowed</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">field</span><span class="o">.</span><span class="n">null</span>

<span class="k">def</span> <span class="nf">get_order_dir</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;ASC&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the field name and direction for an order specification. For</span>
<span class="sd">    example, &#39;-foo&#39; is returned as (&#39;foo&#39;, &#39;DESC&#39;).</span>

<span class="sd">    The &#39;default&#39; param is used to indicate which way no prefix (or a &#39;+&#39;</span>
<span class="sd">    prefix) should sort. The &#39;-&#39; prefix always sorts the opposite way.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dirn</span> <span class="o">=</span> <span class="n">ORDER_DIR</span><span class="p">[</span><span class="n">default</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">field</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dirn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">field</span><span class="p">,</span> <span class="n">dirn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">setup_join_cache</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The information needed to join between model fields is something that is</span>
<span class="sd">    invariant over the life of the model, so we cache it in the model&#39;s Options</span>
<span class="sd">    class, rather than recomputing it all the time.</span>

<span class="sd">    This method initialises the (empty) cache when the model is created.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sender</span><span class="o">.</span><span class="n">_meta</span><span class="o">.</span><span class="n">_join_cache</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">signals</span><span class="o">.</span><span class="n">class_prepared</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">setup_join_cache</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">add_to_dict</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper function to add &quot;value&quot; to the set of values for &quot;key&quot;, whether or</span>
<span class="sd">    not &quot;key&quot; already exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">value</span><span class="p">])</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/django",depth:4}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../../javascript/docco.min.js"></script>
</html>
